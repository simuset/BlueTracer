% !TEX root = LMThesisNicchi.tex

\chapter{Implementation}
In this chapter BlueTracer's implementation will be discussed, providing a detailed account on how the tool is organized, on the design choices which were made during its development process, on how encountered challenges were dealt with and on the decisions which were taken to improve performance.

BlueTracer, being a part of Blue Pill, is also implemented using Pin, a dynamic binary instrumentation framework by Intel, which is vastly utilized for program analysis, testing of software and in the security field. The version of Pin used for the development of the tool is 3.5, in order to benefit from the notable improvements, both in terms of execution speed and offered features, which were introduced going from the 2.14 release to the 3.x series. Pin comes with its own OS-agnostic and compiler-agnostic runtime, called PinCRT. PinCRT exposes three layers: a generic operating system interface providing basic OS services (e.g. process and thread control), together with C and C++03 (without RTTI) runtime layers, for writing instrumentation and analysis routines \cite{Pin}.   

BlueTracer has been organized primarily taking into account the rich set of APIs offered by Pin, which have led to the decision to split the tool in three parts: the first aimed at \textbf{native APIs tracing}, the second for \textbf{APIs tracing} and the last focused on \textbf{callbacks and APCs tracing} (\textit{Figure 3.1}). In particular, the tracing of native APIs also employs a different source of API information (\textit{Dr. Memory}'s system call data) than the ones utilized for tracing APIs (\textit{drltrace}'s configuration file or the information extracted from \textit{Pyrebox}'s database).

This chapter will begin by describing how multi-threading was addressed in the tool, as this is central to all its components. Then, the implementation of each one of three aforementioned parts will be discussed in detail. 
\iffalse
Finally, all the configuration options of the tool will be explained.          
\fi

\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{Figures/BlueTracer.pdf}
\caption{\textit{BlueTracer's high level structure}}
\end{figure}

\section{Thread Management}

Since the samples under analysis are typically multithreaded applications, let us go through the mechanisms exposed by Pin to manage threads and how those were employed in the implementation of the tool.

Pin assigns to each thread an ID, a small number beginning at 0
which is not the same as the operating system thread ID. A way to obtain such ID is by using as analysis routine argument \texttt{IARG\_THREAD\_ID}, which passes the thread ID assigned by Pin for the calling thread. This ID is typically used as an index of an array of thread data.
In fact, the Pin API makes available an efficient thread local storage (TLS). In order to utilize it, it is first required to allocate a new TLS key via \texttt{PIN\_CreateThreadDataKey}, which can optionally take as input a pointer to a destructor function. After that, any thread of the process can use the TLS key, in addition to its Pin-specific thread ID, to store (\texttt{PIN\_SetThreadData}) and retrieve (\texttt{PIN\_GetThreadData}) values in its own slot. The starting value relative to the key in every thread is \texttt{NULL}.
Pin makes also available call-backs when each thread starts (registered with \texttt{PIN\_AddThreadStartFunction}) and ends (registered with \texttt{PIN\_AddThreadFiniFunction}). This is typically where thread local data is allocated, manipulated and stored in a thread's local storage\cite{Pin}.

In BlueTracer, each TLS slot stores a \texttt{struct} of the type \texttt{bluepill\_tls} (\textit{Listing 3.1}) for every thread. Such \texttt{struct} is dynamically allocated every time a thread starts in the \texttt{OnThreadStart} callback function and is consequently deallocated in the \texttt{onThreadFini} function when the thread ends.

\vspace{0.5cm}
\begin{lstlisting}[caption={Thread Local Data},captionpos=b]
typedef struct {
 ...
 syscall_tracer* syscallEntry;     // Pointer to NTAPI entry
 vector<stackEntry>* shadowStack;  // Shadow stack
 uint call_number;             	   // Calls counter							
 
 buf_info_t* buffer;		   	   // Buffer for writing to file				 
 FILE* OutFile;                    // Output file pointer
 
 // Pointer to function for opening file/writing to file	
 void(*file_write)(THREADID, buf_info_t*, FILE*, const char*, 	...);
 
 ...
} bluepill_tls;
\end{lstlisting}

Since the first three fields of the above \texttt{struct} (lines 3-5) are employed when tracing native APIs and APIs, they will be discussed in detail later in the chapter. Now let us focus on the remaining fields, which are used by BlueTracer to write the traced information in the appropriate log files. 

\subsection{Log Files and Multithreading}

In BlueTracer, the traced data is written to a binary file, one for every thread. The default naming convention used for the tracer's log files is \texttt{Traced.[OS Process ID].[Pin-specific Thread ID]}, similarly to the one Blue Pill employs in its own log files, with the user being able to change \texttt{Traced} with a name of its choice in the configuration file. 

When writing data to file, each thread invokes the \texttt{file\_write} function, whose pointer is located in the instance of the \texttt{bluepill\_tls} struct associated to the thread (line 11 of \textit{Listing 3.1}). However, such data, which follows the same format of strings used by \texttt{fprintf}, is not directly written to file. Instead, an intermediate 8 kB buffer is used (line 7 of \textit{Listing 3.1}): only when the buffer is full (or when the amount of data to be written does not fit the buffer) file writing actually occurs. The choice of using a buffer was made as an attempt to improve performance, as it allows the aggregation of small write operations into a block size that is more efficient for the disk subsystem.

A problem which was encountered when trying to conjugate file management and multithreading is that there exists a known isolation issue affecting Pin on Windows. Specifically, it is possible for a deadlock to take place if a file is opened in a callback in the context of multithreaded applications. As a result of this issue, it is not possible to open the tracer's log file in the \texttt{OnThreadStart} callback. Pin's manual proposes to circumvent the problem by opening the file in the \texttt{main} and tagging the data with the thread ID \cite{Pin}. However, this conflicts with the idea of having one file for each thread.

In order to bypass this limitation of the Pin's framework, the following strategy was employed:
\begin{enumerate}
\item When initializing the thread local data in \texttt{OnThreadStart}, \texttt{file\_write} is set to point to a function named \texttt{file\_open}.
\item The first time a thread attempts to write data to file \texttt{file\_open} is invoked.
\\
\\
\item \texttt{file\_open} carries out the following actions:
\begin{enumerate}
\item Opens the tracer's log file (this is safe since the file is not opened in a callback)
\item Sets the obtained file pointer in the thread local data (line 8 of \textit{Listing 3.1})
\item Adds the data to be written in the buffer (which is eventually written to file if the buffer is too small to hold it)
\item Sets \texttt{file\_write} to point to \texttt{buf\_write}, a function which is in charge of just writing data to the buffer and to file.
\end{enumerate}
\item As a result of this, when the thread attempts to write to file again, \texttt{buf\_write} is invoked, thus allowing the thread to just write to file without going through opening the file again.   
\end{enumerate}   

\section{Native APIs Tracing}
\iffalse
Talk about log structure when talking about how arguments are printed
\fi

Windows Native APIs are employed to call operating system services in kernel mode in a controlled way.  
In fact, all core Windows components, which possess direct access to hardware and services in charge of handling the computer's resources (e.g. memory), operate in kernel mode. This means that, every time a user mode application desires to carry out certain actions, like for instance starting a thread or allocating virtual memory, they must rely on kernel mode  services. The Windows Native API corresponds to the system call interface of standard monolithic operating systems, such as the majority of UNIX-like systems, with the difference that in the latter case the system call interface is documented and can be utilized directly by applications. Instead, due to Windows' architecture, Windows Native APIs are concealed to the programmer by the higher level Windows (\texttt{Win32}) APIs \cite{NTAPI1}. User mode Windows Native APIs, which are identified by their \texttt{Nt} prefix and are exported by \texttt{ntdll}, have caught the attention of malware writers since they are seen as a way of bypassing the documented APIs with the objective of performing a series of actions without being discovered \cite{NTAPI2}. For this reason it is a good idea to also trace them, in addition to the ordinary Windows APIs.  

Pin provides a set of APIs aimed at assisting the extraction of information relative to the system calls made by the pinned application, also including information relative to Windows Native APIs. In particular, in Blue Pill (and consequently in BlueTracer) \texttt{PIN\_AddSyscallEntryFunction} and  \texttt{PIN\_AddSyscallExitFunction} were used for this purpose. In fact, these allow to register notification functions which are called immediately before and after the execution of a system call \cite{Pin}. In BlueTracer, the function in charge of gathering Native API information before execution is \texttt{TraceSysCallEntry} while the one responsible for collecting Native API information after execution is \texttt{TraceSysCallExit}. They have been both been embedded in Blue Pill's notification functions and their overall structure is detailed in \textit{Figure 3.2}.
\\
\begin{figure}[h]
\centering
\includegraphics[scale=0.75]{Figures/NTAPITracing.pdf}
\caption{\textit{Native APIs Tracing Workflow}}
\end{figure}
\\
Following \textit{Figure 3.2}, let us now thoroughly analyze the main steps which take place when Native APIs are traced.

\subsection{Main Image Check}
In order to filter the logged information relative to Native APIs, BlueTracer allows the analyst to decide, through the use of a boolean parameter (\texttt{MainImage}) in the configuration file, whether or not only Native APIs called invoked directly from the main executable of the pinned application should be traced. Therefore, as it can be seen in \textit{Figure 3.2}, the first thing which is done in \texttt{TraceSysCallEntry}, assuming that the \texttt{MainImage} configuration parameter has been set to \texttt{true}, is to determine if the Native API call is taking place directly from the main executable.

To this end, Pin's \texttt{IMG} APIs are employed, where in Pin an \texttt{IMG} represents all the data structures relative to binaries and shared libraries \cite{Pin}. Specifically, in Blue Pill, \texttt{IMG\_AddInstrumentFunction} is utilized to register a callback which is invoked each time an image is loaded. Inside such callback, which takes as one of the input parameters the \texttt{IMG} object representing the image being loaded, the following steps are taken:
\begin{enumerate}
\item \texttt{IMG\_IsMainExecutable} is employed to determine if the image being loaded is the main executable of the pinned application.
\item If this is the case, \texttt{IMG\_HighAddress} and \texttt{IMG\_LowAddress} are invoked. These two APIs return the highest address and the lowest address respectively of any code or data loaded by the image corresponding the the \texttt{IMG} object they take as input. By employing these APIs is therefore possible to determine the address range relative to the main executable. 
\end{enumerate}  

Having obtained the main executable address range in this way, it is then employed in \texttt{TraceSysCallEntry} to learn if the Native API call is occuring directly from the main image. Internally, before entering kernel mode every Native API executes some common code, i.e. each Native API stores its ordinal in the \texttt{eax} register and invokes \texttt{KiFastSystemCall}, where the \texttt{sysenter} instruction is used to actually enter kernel mode. When \texttt{sysenter} is executed, the kernel obtains the ordinal number from \texttt{eax} and utilizes it to call the corresponding function, prior to going back to user mode \cite{MalwareTech}.

In Pin, the Native API is intercepted right before \texttt{sysenter} is executed. This could be inferred by the fact that, in \texttt{TraceSysCallEntry}, the instruction pointer (obtainable via the \texttt{PIN\_GetContextReg} API) contains \texttt{sysenter}'s address. In light of this, in addition to the fact that each Native API calls \texttt{KiFastSystemCall} without setting a stack frame, the application's stack during the execution of \texttt{TraceSysCallEntry} is in the following state (\textit{Figure 3.3}).
\\
\begin{figure}[h]
\centering
\includegraphics[scale=1]{Figures/StackMainImage.pdf}
\caption{\textit{Stack before} \texttt{sysenter} \textit{execution}}
\end{figure}     

Having outlined the general situation, it is finally possible to describe how the main image check is carried out:

\begin{enumerate}
\item The first check involves discovering whether or not \texttt{sysenter} is called directly from the main executable. As Pin intercepts Native APIs right before the execution of \texttt{sysenter}, this can be trivially done by checking if the instruction pointer value obtained in \texttt{TraceSysCallEntry} falls within the main executable memory address range.
\item Secondly, it is required to examine if the Native API return address belongs to the main executable. As a result of what shown in \textit{Figure 3.3} such return address is obtained by adding 4 to the stack pointer and retrieving the pointed value, where the stack pointer can be obtained in Pin through the use of \texttt{PIN\_GetContextReg}. The resulting value is then, once more, compared with the main executable memory address range.
\end{enumerate}

\subsection{Native API Name Resolution}

Previously, it was stated how it is possible to register a callback function to be executed before Native APIs through the use of \texttt{PIN\_AddSyscallEntryFunction}. Such callback functions, named \texttt{SYSCALL\_ENTRY\_CALLBACK}s, receive a set of parameters, including \texttt{ctx}, the application's register state immediately before the system call execution, and \texttt{std}, the system call standard. In Blue Pill, these two parameters are used to invoke \texttt{PIN\_GetSyscallNumber} inside its \texttt{SYSCALL\_ENTRY\_CALLBACK}. Such API returns the number (ID) of the Native API to be executed in the provided context \cite{Pin}.

Blue Pill employs a mechanism which allows it to obtain the Native API name from its number, since the hooking functions it employs are indexed by name and not by ordinal. This choice was made because the identifiers vary depending on the Windows version, even among different Service Pack versions. For the same reason, the information needed by BlueTracer to correctly log Native APIs is also indexed by Native API name and, consequently, BlueTracer also utilizes the aforementioned Native API name resolution mechanism.

The idea is to create an array, named \texttt{syscallIDs}, where Native API names are indexed by their IDs, by parsing \texttt{ntdll}'s export information. The export data of a PE is stored in the \texttt{IMAGE\_EXPORT\_DIRECTORY} structure located in the header. In our case, the most relevant fields of this structure are:

\begin{itemize}
\item The \texttt{AddressOfFunctions} array, which contains RVAs \footnote{A RVA (Relative Virtual Address) is essentially an offset within the PE image in memory} pointing to the actual exported functions and is indexed by an export ordinal.
\item The \texttt{AddressOfNames} array, which is an array of 32-bit RVAs pointing to symbol strings.
\item The \texttt{AddressOfNameOrdinals} array, which is an array of 16-bit ordinals existing in parallel with \texttt{AddressOfNames}, i.e. they possess the same number of elements and there is a direct relation between equivalent indices \cite{Sikorski:2012:PMA:2181153}.  
\end{itemize}

\newpage

With this in mind, \texttt{syscallIDs} is built by carrying out the following actions for every element \texttt{iName} in \texttt{AddressOfNames}:

\begin{enumerate}
\item The corresponding \texttt{AddressOfNameOrdinals} element is retrieved, i.e. the one with the same index. Let us call this value \texttt{iOrdinal}.
\item \texttt{iOrdinal} is used to index in \texttt{AddressOfFunctions}. This time the obtained value is the RVA pointing to the exported function.
\item The pointed function is expected to begin \texttt{mov eax, syscall\_number}. As a result of this, the first byte should be \texttt{B8h} and the syscall number can be obtained by considering the next four bytes.  
\end{enumerate}

By following the above procedure, every element in \texttt{AddressOfNames} can be therefore mapped to the corresponding identifier. 

\subsection{Native API Information Representation and Retrieval}

When tracing Native APIs, it is wanted to record as much data as possible as well as correctly formatting the arguments' values. To do this, it is required to have access to some kind of source of Native API related information, which can assist the tracer in the logging activity by, for example, providing the number of arguments a Native API takes as input, listing the arguments' types and differentiating between input and output arguments.
In BlueTracer, this information was adapted from the Native API data provided by Dr.Memory \cite{DrMemory}, a memory monitoring tool based on the DynamoRIO DBI framework.

For each Native API, the information related to it is contained in a \texttt{struct} of type \texttt{syscall\_info\_t} (\textit{Listing 3.2}). Most fields of such \texttt{struct} are self-explanatory. In particular, \texttt{num} is a \texttt{struct} storing two values indicating the system call number; these are filled in dynamically by Dr.Memory but are not needed by BlueTracer. Furthermore, the \texttt{flags} field is utilized to notify whether or not all the details of the Native API are known, as most Native APIs are undocumented. Undoubtedly though, a major role is played by the \texttt{arg} array, which is made up by \texttt{sysinfo\_arg\_t} \texttt{struct}s (\textit{Listing 3.2}) containing the data of the Native API arguments. This array is initialized with size \texttt{MAX\_ARGS\_IN\_ENTRY} (i.e. 18), since a Native API can have at most 18 arguments. 
\\
\begin{lstlisting}[caption={\texttt{struct} containing Native API related information},captionpos=b]
	typedef struct _syscall_info_t {

		drsys_sysnum_t num;			// Native API ID
		const char *name;			// Native API Name
		uint flags; 				// SYSINFO_ flags
		uint return_type; 			// Return type
		int arg_count;				// Number of arguments

		// Array of arguments
		sysinfo_arg_t arg[MAX_ARGS_IN_ENTRY];

		...
	} syscall_info_t;
\end{lstlisting}

\begin{lstlisting}[caption={\texttt{struct} containing information associated to a Native API argument},captionpos=b]
	typedef struct _sysinfo_arg_t {
		int param; 				    // Parameter Ordinal
		int size; 				    // Size
		uint flags; 				// SYSARG_ flags
		int type; 				    // Type
		const char *type_name; 	    // Symbolic Name of the arg Type
	} sysinfo_arg_t;
\end{lstlisting}

In \texttt{sysinfo\_arg\_t}, other than \texttt{param} and \texttt{size}, that are straightforward, the following fields are also present:
\begin{itemize}
\item \texttt{flags}, which stores an \texttt{OR} of flags describing the argument's characteristics. The most important ones are:

\begin{itemize}
\item \texttt{SYSARG\_READ (R)} : input argument. 
\item \texttt{SYSARG\_WRITE (W)} : output argument.
\item \texttt{SYSARG\_INLINED} : non-memory argument, i.e the whole value is in parameter slot.
\item \texttt{SYSARG\_HAS\_TYPE (HT)} : argument with a type specifier. In fact, a non \texttt{SYSARG\_INLINED} argument is by default of type \texttt{struct} (\texttt{DRSYS\_TYPE\_STRUCT}), unless specified otherwise by \texttt{SYSARG\_HAS\_TYPE}. 
\end{itemize}

\item \texttt{type}, which is an \texttt{enum} value indicating the data type of the parameter

\item \texttt{type\_name}, a string indicating the symbolic name of the \texttt{arg} type, which is typically filled dynamically based on the \texttt{type} value. In case the argument value is a named constant, the \texttt{type\_name} field contains the name of the enumeration the constant belongs to. In fact, for each one of these enumerations, BlueTracer has access to a \texttt{struct} specific for that enumeration containing the constant values and their corresponding name. This information was also provided by Dr.Memory and is employed to translate constants to the appropriate name, as it will be explained in the next section. 

\end{itemize}

To make things clearer, an instance of \texttt{syscall\_info\_t} for the Native API \texttt{NtAllocateVirtualMemory} was provided in the listing below (\textit{Listing 3.4}).
\\
\begin{lstlisting}[caption={Instance of \texttt{syscall\_info\_t} relative to \texttt{NtAllocateVirtualMemory}},captionpos=b]
	{ { 0,0 },"NtAllocateVirtualMemory", OK, RNTST, 6,
	{
		{ 0, WIN_SIZE(HANDLE), SYSARG_INLINED, DRSYS_TYPE_HANDLE },
		{ 1, WIN_SIZE(PVOID), R | WR | HT, DRSYS_TYPE_POINTER },
		{ 2, WIN_SIZE(ULONG), SYSARG_INLINED, DRSYS_TYPE_UNSIGNED_INT },
		{ 3, WIN_SIZE(ULONG), R | WR | HT, DRSYS_TYPE_UNSIGNED_INT },
		{ 4, WIN_SIZE(ULONG), SYSARG_INLINED, DRSYS_TYPE_UNSIGNED_INT, "MEM_COMMIT" },
		{ 5, WIN_SIZE(ULONG), SYSARG_INLINED, DRSYS_TYPE_UNSIGNED_INT, "PAGE_NOACCESS" },
	}
\end{lstlisting}

In \textit{3.2.2} it was explained how BlueTracer obtains a Native API name from its ID. After that, as shown in \textit{Figure 3.2}, there must be a way to, given a specific Native API name, retrieve the corresponding \texttt{syscall\_info\_t struct}. This is done by building an hash map during the tool's initialization which maps the Native API name to the appropriate \texttt{struct}. Such idea is also adopted for named constants enumerations since a hash map is also constructed with the objective of associating the name of a named constant enumeration to the corresponding \texttt{struct}.    

\subsection{Native API Logging}
With reference to \textit{Figure 3.2}, let us consider the point in \texttt{TraceSysCallEntry} where the \texttt{syscall\_info\_t struct} relative to the Native API being traced was successfully retrieved. Before describing how the logging of "known" Native APIs is performed, it is worth mentioning that, in case a \texttt{struct} describing a certain Native API is not found, BlueTracer just logs the name of the Native API and the input value of a user-specified number of arguments (4 by default).

The first step towards logging "known" Native APIs is allocating and initializing a \texttt{syscall\_tracer struct} (\textit{Listing 3.5}) representing the specific Native API being traced. This \texttt{struct} is built starting from the data present in the previously retrieved  \texttt{syscall\_info\_t struct} and it is at the heart of the logging of the Native API.
\\
\begin{lstlisting}[caption={\texttt{struct} representing the Native API being traced},captionpos=b]
	typedef struct _syscall_tracer {
		ADDRINT syscall_number;			// Native API ID
		const char * syscall_name;		// Native API Name
		int argcount;				    // Number of Arguments

		// Array of arguments
		drsys_arg_t arguments[MAX_ARGS_IN_ENTRY];

		drsys_arg_t retval;			    // Return value
		int syscall_counter;			// Native API Counter
	} syscall_tracer;
\end{lstlisting}

Even for \texttt{syscall\_tracer}, each field is self-explanatory. The only one which was not encountered before is the \texttt{syscall\_counter} field. The rationale behind this field is that, in the log, each traced call has a unique integer associated to it, utilized to group together the information relative to the call in post-processing. The next identifier to be assigned is stored in the \texttt{call\_number} field of the thread local storage (\textit{Listing 3.1}). Therefore, \texttt{syscall\_counter} simply contains the unique identifier associated to the Native API in the log. The arguments of a specific Native API are represented via the \texttt{drsys\_arg\_t} struct (\textit{Listing 3.6}).
\\
\begin{lstlisting}[caption={\texttt{struct} representing the an argument of the Native API being traced},captionpos=b]
typedef struct _drsys_arg_t {

	// Whether operating pre-call (if true) or post-system call (if false)
	bool pre;

	int ordinal;			    // Parameter Ordinal				
	int size;			        // Size	
	uint flags;			        // SYSARG_ flags
	int type;			        // Type
	const char *type_name;		// Symbolic Name of the arg Type

	// String describing the symbolic name of a named constant's enum
	const char *enum_name;

	// Argument value
	ADDRINT value;
	
} drsys_arg_t
\end{lstlisting}

\texttt{drsys\_arg\_t}'s fields are mostly the same of \texttt{sysinfo\_arg\_t}, with three additions:
\begin{itemize}
\item \texttt{pre}, which is a boolean flag set to \texttt{true} when the logging is occurring before the Native API is executed (i.e. in \texttt{TraceSysCallEntry} and set to false when the logging is occurring after the Native API is executed (i.e. in \texttt{TraceSysCallExit}).
\item \texttt{enum\_name}, a string containing the symbolic name of the enumeration a named constant belongs to. In most cases, this is the symbolic name associated to the first constant of the enumeration. Such field was introduced to decouple type name and enumeration name.
\item \texttt{value}, an \texttt{ADDRINT}\footnote{The ADDRINT type is defined by Pin and represents a memory address} containing the value of the argument. This is obtained through the \texttt{PIN\_GetSyscallArgument} API, which takes as input the context before the execution of the system call, the system call standard and the ordinal number of the argument whose value is requested.  
\end{itemize}

As previously mentioned in section 3.1.1, each thread possesses its own log file, whose pointer resides in the thread local storage, and writes on it by means of the \texttt{file\_write} function, also located in the thread local storage (\textit{Listing 3.1}). The first Native API component being logged is its name and this is done with the following format:
\\ 
\texttt{\textasciitilde\textasciitilde[System ID of thread]\textasciitilde\textasciitilde} \texttt{ [Call Counter] [Image Name]![Native API Name]}  
In the context of Native APIs, the name of the image is always \texttt{ntdll}, but this is not the case when tracing APIs.

Argument logging is done via the \texttt{print\_arg} function (\textit{Listing 3.7}).

\newpage
\begin{lstlisting}[caption={\texttt{print\_arg} function},captionpos=b]
static void print_arg(drsys_arg_t* curr_arg, bluepill_tls* tdata, uint syscall_counter) {

	...

	// Constant Resolution
	if (curr_arg->enum_name != NULL) {
		if (get_arg_symname(curr_arg, tdata))
			return;
	}

	switch (curr_arg->type) {
		case DRSYS_TYPE_VOID:	      print_simple_value(curr_arg, true, tdata); break;
		case DRSYS_TYPE_POINTER:      print_simple_value(curr_arg, true, tdata); break;
		case DRSYS_TYPE_BOOL:         print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_INT:          print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_SIGNED_INT:   print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_UNSIGNED_INT: print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_HANDLE:       print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_NTSTATUS:     print_simple_value(curr_arg, false, tdata); break;
		case DRSYS_TYPE_ATOM:         print_simple_value(curr_arg, false, tdata); break;
	default: {
		if (curr_arg->value == 0) {
			(tdata->file_write)(tdata->threadid, tdata->buffer, tdata->OutFile, "<null>");
		}
		else if (!TEST(SYSARG_READ, curr_arg->flags)) {
			(tdata->file_write)(tdata->threadid, tdata->buffer,
			tdata->OutFile, PFX, curr_arg->value);
		}

		else {
			if (!print_known_compound_type(curr_arg, tdata))
				(tdata->file_write)(tdata->threadid, tdata->buffer, tdata->OutFile, "<NYI>");
		}

	}
}
\end{lstlisting}
 

\section{API}
In tracing APIs most of the idea seen in Native API tracing also apply, with a few differences.
-> Same diagram as NTAPI with 2 sources AND shadow stack

\subsection{Shadow Stack}
\subsection{Performance}
\section{Callback and APC} 

\iffalse
\section{Tool Configuration}
\fi
