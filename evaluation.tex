% !TEX root = LMThesisNicchi.tex

\chapter{Experimental Evaluation} \label{results}

In this chapter we will illustrate the results obtained during the experimental evaluation of BlueTracer.

We first tested the tool on a set of benign applications performing different tasks, in order to assess its run-time overhead. Then, we validated BlueTracer using \textit{Al-Khaser} \cite{AlK}, a popular open-source project employed to assess how stealthy a malware analysis system is with respect to a large portion of public evasion techniques used by real malware families. Finally, we employed BlueTracer to analyze a group of highly-evasive real malware samples collected by Joe Security \cite{JoeBox}, the proclaimed technology leader for the analysis of evasive malware.

\iffalse
If JoeBox added differentiate machines
\fi
The tests on benign applications and on \textit{Al-Khaser} were conducted on a VirtualBox (version 5.2.6)  Virtual Machine with 1 CPU core and 3 GB of RAM running Windows 7 32-bit, where the specifications of the host machine are:
\begin{itemize}
\item \textbf{Operating System:} Linux Mint 17.3 
\item \textbf{Processor:} Intel Core i7-3537U CPU @ 2.00 GHz $\times$ 2
\item \textbf{RAM:} 8 GB  
\end{itemize}

Instead, the tests on real malware instances were performed on a VirtualBox (version 5.2.0)  Virtual Machine with 4 CPU cores and 3 GB of RAM running Windows 7 32-bit, where the specifications of the host machine are:
\begin{itemize}
\item \textbf{Operating System:} Debian Wheezy 7 
\item \textbf{Processor:} Intel Xeon E5-4610 v2 CPU @ 2.3 GHz
\item \textbf{RAM:} 128 GB  
\end{itemize}
 

\section{Run-Time Overhead Assessment}

In order to evaluate the run-time overhead introduced by BlueTracer we tested it with a number of benign applications exercising a large number of functions. We had to perform this kind of test on deterministic batch programs to obtain accurate results rather than on real malware samples. This because malware instances have unpredictable behaviour, thus rendering the execution times obtained when running them meaningless.
Having in mind the goal of experimenting with a wide range of different functionalities, we picked a set of well-known Windows applications performing a variety of jobs. We grouped these applications based on the task they carry out, as shown below:

\begin{itemize}
\item \textbf{Collection of system information}
	   \begin{itemize}
	   \item \texttt{Systeminfo.} It outputs a summary of OS-environment parameters. 
	   \item \texttt{System File Checker (SFC).} It scans for corruptions in system files.
	   \item \texttt{Check Disk}. It checks the disks' integrity.
	   \item \texttt{IPConfig}. It displays TCP/IP network configuration values.
	   \item \texttt{Netstat}. It can show active TCP connections as well as TCP and UDP ports on which the computer is listening.
	   \item \texttt{Driver Query}. It presents the list of installed drivers and their properties.
	   \item \texttt{Windows Assessment Tools (WinSAT).} It  measures a number of performance characteristics and reports them.
	   \item \texttt{Powercfg.} It enables to search for common energy-efficiency problems. 
	   \end{itemize}
\item \textbf{Compression programs}
		\begin{itemize}
		\item \texttt{7zip.} Its default output extension is \texttt{.7z}.
		\item \texttt{IZArc.} Its default output extension is \texttt{.zip}.
		\item \texttt{WinRar.} Its default output extension is \texttt{.rar}.
		\end{itemize}
\item \textbf{Encryption Utilities}
		\begin{itemize}
		\item \texttt{Cipher.} It uses Encrypting File System (ESF), based on DESX. 
		\item \texttt{OpenSSL.} It was configured to employ 256-bit CBC AES.
		\item \texttt{Crypt.} It adopts RC2 block encryption.
		\end{itemize}
\item \textbf{Hashing Utilities}
		\begin{itemize}
		\item \texttt{File Checksum Integrity Verifier (FCIV).} It was set to use both MD5 and SHA1.
		\item \texttt{TurboSFV.} It was configured to adopt SHA3-224. 
		\end{itemize}
\end{itemize}

We first recorded the native execution time for each of the aforementioned applications. Then, we ran them under BlueTracer, logging the respective execution times. Specifically, the following BlueTracer modes of operation were employed:

\begin{itemize}
\item \textbf{Empty Image.} All image notification functions are empty, that is, they just increase a global counter value. This means that no analysis routines are inserted at run-time. 
\item \textbf{Empty Routine.} All analysis routines are empty, i.e., all they do is, once again, increase a global counter value. So, here, with respect of \textbf{Empty Image}, there is an additional cost instrumentation cost derived from the insertion of analysis routines, which collect data but do not analyze it.  
\item \textbf{Main Image.} Only Native APIs and APIs being directly invoked from the main executable of the pinned application are traced. This is BlueTracer's default mode of operation. 
\item \textbf{Complete.} Every event is traced, also including Native APIs and APIs being invoked outside the main executable (e.g., within libraries).
\end{itemize}

We tested every benign application in the previous page adopting each of the above operation modes, which can be set using BlueTracer's configuration file. Essentially, \textbf{Empty Image} and \textbf{Empty Routine} were utilized to determine the run-time overhead introduced just by the Pin's framework, when no analysis is actually performed. On the contrary, \textbf{Main Image} was adopted to show BlueTracer's overhead during a typical use of the tool, as \textbf{Main Image} is BlueTracer's default mode. Lastly, \textbf{Complete} was employed to determine how BlueTracer's behaves under heavy stress conditions.

We tested each application three times and then recorded the average execution time. For the compression programs, the file being compressed was the Puppy Linux ISO (\texttt{xenialpup-7.5-uefi.iso}), of size 332 MBs. On the other hand, for the encryption and hashing utilities, we used the Ubuntu 18.04 ISO (\texttt{ubuntu-18.04-desktop-amd64}), the size of which is 1.8 GB. During the tests, we also decided to stop the execution of the pinned application if, after it had been running for more than 10 minutes, the log file was greater than 5 GB. This had to be done due to the hard drive limitations of the testing platform.      

The recorded execution times can be observed in \textit{Table 4.1}. As the reader can see, as more demanding modes of operation are employed, the running time increases, although the increment is not uniform, but is actually quite variable across the different applications.

In light of this, to actually quantify the run-time overhead we decided to adopt the following metric:
\vspace{-0.1cm}
\begin{align*}
\text{Overhead per Event} = \frac{T_{instrumented} - T_{native}}{Events}
\end{align*}

where:
\begin{itemize}
\item $T_{instrumented}$ is the application's execution time when executed under BlueTracer with the \textbf{Complete} mode of operation enabled. We chose the \textbf{Complete} mode of operation to quantify the overhead per event in the worst-case situation.
\item $T_{native}$ is the application's native execution time.
\item $Events$ is the total number of Native API and API calls performed by the analyzed application.
\end{itemize}

\textit{Table 4.2} lists the overhead per event value of each benign application for which the execution time in the \textbf{Complete} mode of operation could be obtained. In this case we can see that the typical overhead is approximately in the range of 40 - 220 microseconds per operation, with the compression programs being an exception, as they have a greater overhead per event value than the rest.

%\vspace*{0.8cm}
\begin{sidewaystable}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{6}{Y}}

\hline
\hline
   \textbf{Application} & \specialcell{ \textbf{Native} \\ \textbf{(s)}} & \specialcell{ \textbf{Empty Image} \\ \textbf{(s)}} & \specialcell{ \textbf{Empty Routine} \\ \textbf{(s)}} & \specialcell{ \textbf{Main Image} \\ \textbf{(s)}} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} \\
\hline
\texttt{Systeminfo}      & 5.894    & 9.686 (1.64x)  & 12.869 (2.18x) & 15.694 (2.66x) & 26.398 (4.48x)     \\
\texttt{SFC}          & 218.251 & 222.065 (1.02x) & 226.125 (1.04x) & 230.869 (1.06x) & 245.476 (1.12x)       \\
\texttt{Check Disk}       & 101.570     & 171.94 (1.69x) & 181.429 (1.79x) & 454.649 (4.48x) & 600+       \\
\texttt{IPConfig}       & 0.105     & 4.257 (40.54x) & 8.421 (80.20x) & 9.599 (91.42x) & 13.181 (125.53x)      \\
\texttt{Netstat} & 0.085 & 2.563 (30.15x) & 4.630 (54.47x) & 6.902 (81.20x) & 21.129 (248.58x)       \\
\texttt{DriverQuery} & 1.168 & 6.663 (5.70x) & 9.786 (8.38x) & 34.074 (29.17x) & 68.668 (58.79x)     \\
\texttt{WinSat}       & 163.175     & 212.496 (1.30x) & 221.012 (1.35x) & 273.641 (1.68x) & 600+      \\
\texttt{PowerCFG} & 61.333      & 73.325 (1.20x) & 80.018 (1.30x) & 132.466 (2.16x) & 273.882 (4.47x)       \\
\texttt{7zip}       & 175.526     & 212.000 (1.21x) & 225.091 (1.28x) & 227.985 (1.30x) & 233.792 (1.33x)      \\
\texttt{IZArc}      & 30.920     & 52.878 (1.71x) & 56.631 (1.83x) & 61.066 (1.97x) & 65.770 (2.13x)      \\
\texttt{WinRar} & 155.674 & 192.638 (1.24x) & 198.804 (1.28x) & 208.606 (1.34x) & 215.455 (1.38x)      \\
\texttt{Cipher} & 0.028 & 1.817 (64.89x) & 3.787 (135.25x) & 4.435 (158.39x) & 5.064 (180.86x)       \\
\texttt{OpenSSL} & 24.769 & 33.183 (1.34x) & 34.308 (1.39x) & 47.006 (1.90x) & 1524.763 (61.56x)      \\
\texttt{Crypt} & 65.392 & 140.048 (2.14x) & 142.979 (2.19x) & 572.353 (8.75x) & 600+      \\
\texttt{FCIV} & 10.807 & 25.113 (2.32x) & 28.144 (2.60x) & 56.329 (5.21x) & 87.948 (8.14x)       \\
\texttt{TurboSFV} & 34.412 & 57.705 (1.68x) & 62.639 (1.82x) & 66.439 (1.93x) & 74.657 (2.17x)
\\
\hline
\end{tabularx}
\vspace{0.2cm}
\caption{Execution times of instrumented benign applications}

\end{sidewaystable}

\iffalse
\begin{table}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{4}{Y}}
\hline
\hline
\cline{1-2}
   \textbf{Application} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} & \textbf{Events} & \specialcell{ \textbf{Overhead / Event} \\ \textbf{(s)}} \\
\hline
\texttt{Systeminfo}      & 26.398    & 387 476      \\
\texttt{System File Checker}          & each        & 0.01       \\
\texttt{Check Disk}       & stuffed     & 92.50      \\
\texttt{IPConfig}       & stuffed     & 33.33      \\
\texttt{Netstat} & frozen      & 8.99       \\
\texttt{DriverQuery}       & stuffed     & 92.50      \\
\texttt{WinSat}       & stuffed     & 33.33      \\
\texttt{PowerCFG} & frozen      & 8.99       \\
\texttt{7zip}       & stuffed     & 92.50      \\
\texttt{IZArc}      & stuffed     & 33.33      \\
\texttt{WinRar} & frozen      & 8.99       \\
\texttt{Cipher} & frozen      & 8.99       \\
\texttt{OpenSSL}       & stuffed     & 92.50      \\
\texttt{Crypt}      & stuffed     & 33.33      \\
\texttt{FCIV} & frozen      & 8.99       \\
\hline
\end{tabularx}
\caption{Run-time overhead for benign applications}
\end{table}
\fi

\vspace*{0.8cm}
\begin{sidewaystable}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{6}{Y}}

\hline
\hline
   \textbf{Application} & \specialcell{ \textbf{Native} \\ \textbf{(s)}} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} & \textbf{Events} & \specialcell{ \textbf{Overhead per Event} \\  \textbf{($10^-5$ s)} }  \\
\hline
\texttt{Systeminfo}      & 5.894    & 26.398  & 387 476 & $5.291$    \\
\texttt{SFC}          & 218.251 & 245.476 & 333 781 & $8.156$ \\
\texttt{IPConfig}       & 0.105 & 13.181 & 94 313 & $13.864$      \\
\texttt{Netstat} & 0.085 & 21.129 & 542 649 & $3.878$       \\
\texttt{DriverQuery} & 1.168 & 68.668 & 1 735 859 & $3.860$            \\
\texttt{PowerCFG} & 61.333 & 273.882 & 4 497 247 & $4.726$       \\
\texttt{7zip}       & 175.526 & 233.792 & 146 578 & $39.751$      \\
\texttt{IZArc}      & 30.920 & 65.770 & 109 142 & $31.931$      \\
\texttt{WinRar} & 155.674 & 215.455 & 84 329 & $70.890$      \\
\texttt{Cipher} & 0.028 & 4.435 & 24 141 & $18.255$           \\
\texttt{OpenSSL} & 24.769 & 1524.763 & 57 410 809 & $2.613$                \\
\texttt{FCIV} & 10.807 & 87.948 & 725 133 &  $10.638$               \\
\texttt{TurboSFV} & 34.412 & 74.657 & 183 455 & $21.937$ 
\\
\hline
\end{tabularx}
\vspace{0.2cm}
\caption{Run-time overhead for benign applications}

\end{sidewaystable}

\vspace{-1cm}
\section{Al-Khaser} \label{Alk}
Al-Khaser \cite{AlK} is a popular open-source application which performs a large number of common checks employed by malware families to determine if they are being executed in an analysis environment. It is typically utilized to assess how stealthy and well hidden a malware analysis system is. For this reason, we chose Al-Khaser as our main validation tool.

The checks implemented by Al-Khaser are divided into categories, with the most significant ones being the following:
\begin{itemize}
\item \textbf{Anti-Debugging}, aimed at detecting the presence of a debugger.
\item \textbf{Anti-Sandbox Timing-based}, the purpose of which is to let sandboxes time out in order to defy analysis. 
\item \textbf{Human Interaction Detection}, which seek to discover the presence of a sandbox by looking for the lack of human interaction with the system.
\item \textbf{Anti-Virtualization}, which have the objective of exposing the use of virtualization and full-system emulation. 
\item \textbf{Anti-Analysis}, aimed at uncovering the employment of common analysis tools (e.g OllyDbg, IDA Pro, etc. ).
\end{itemize}  

When Al-Khaser's executable is run, all the checks are performed and the outcome of each one of them can be easily observed from the command line: \texttt{GOOD} is printed if the analysis product succeeded at remaining hidden, and \texttt{BAD} otherwise. 

To validate BlueTracer, Al-Khaser was run under it in the default \textbf{Main Image} mode. The result was that BlueTracer managed to remain undetected thanks to its integration with BluePill with respect to all the checks performed by Al-Khaser. From this outcome we obtained a first confirmation of BlueTracer's ability to hide its presence. 

Furthermore, to also validate BlueTracer's tracing power, we analyzed the logs obtained when running Al-Khaser, with the objective of finding evidence of the performed evasion checks.
Even in this case, BlueTracer performed well, as the checks could easily be deduced from the log file. 

Let us now show how some of these checks appeared on the log, in order to give a better idea of what BlueTracer is capable of. To be as clear as possible, we will use the same checks categorization as Al-Khaser's.

\subsubsection*{Anti-Debugging}

Anti-debugging checks are essentially aimed at determining if a program is running under a debugger. As already mentioned in Section~\ref{Debugger}, there exist Windows APIs whose objective is exactly to discover if the calling process is being debugged.
A well-known API of this kind is \texttt{IsDebuggerPresent}, which returns a nonzero value if the calling process is running in the context of a debugger and zero otherwise. Such API is employed in one of Al-Khaser's anti-debugging checks and is properly recorded by BlueTracer (\textit{Listing 4.1}). As the reader can see below, the return value is zero, as no debugger is detected.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{IsDebuggerPresent}},captionpos=b]
~~3160~~ 562 kernel32.dll!IsDebuggerPresent
~~3160~~ 563 KERNELBASE.dll!IsDebuggerPresent
563    executed KERNELBASE.dll!IsDebuggerPresent =>
563 	retval: 0x0 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}

Another popular Windows API for debug detection is \texttt{CheckRemoteDebuggerPresent}, which determines if the specified process is being debugged by a "remote" debugger, i.e., a debugger residing in parallel and different process.
Its second argument is a pointer to a boolean, which is set to true if the provided process is being debugged, or false otherwise. Al-Khaser also adopts this API, and, again, BlueTracer correctly logged its invocation (\textit{Listing 4.2}). In addition, it is worth noting that the output value for the second argument (\texttt{arg 1}) is 
false (\texttt{0x0}), thus showing once more that a debugger was not discovered.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{CheckRemoteDebuggerPresent}},captionpos=b]
~~3160~~ 1450 kernel32.dll!CheckRemoteDebuggerPresent
1450 	arg 0: 0xffffffff (name=hProcess, type=DWORD, size=0x4)
1450 	arg 1: 0x002bf710 => 0x0 (name=pbDebuggerPresent, type=(long/int)*, size=0x4)
1450    executed kernel32.dll!CheckRemoteDebuggerPresent =>
1450 	arg 1: 0x002bf710 => 0x0 (name=pbDebuggerPresent, type=(long/int)*, size=0x4)
1450 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

Debugger detection is not only achieved through the use of Windows APIs. In fact, there are also some Native APIs which can be used for this purpose. One of them is \texttt{NtQueryInformationProcess}, which retrieves information related to the specified process. Its second parameter is utilized to specify the type of process information to be retrieved. When set to \texttt{ProcessDebugPort} (value \texttt{0x7}), the Native API provides information on whether the supplied process is being debugged. Specifically, if a debugger is present, the \texttt{ProcessInformation} output parameter is set to a non-zero port number, while, if the process is not under a debugger, this parameter is set to zero \cite{Sikorski:2012:PMA:2181153}. Al-Khaser performs this check and, once more, BlueTracer recorded it (\textit{Listing 4.3}).

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{NtQueryInformationProcess}},captionpos=b]
~~3160~~ 3186 ntdll.dll!NtQueryInformationProcess
3186 	arg 0: 0xffffffff (type=HANDLE, size=0x4)
3186 	arg 1: 0x7 (type=int, size=0x4)
3186 	arg 2: 0x002bf6cc (type=<struct>*, size=0x4)
3186 	arg 3: 0x0 (type=unsigned int, size=0x4)
3186 	arg 4: 0x003c0e98 (type=unsigned int*, size=0x4)
3186    succeeded =>
3186 	arg 2: 0x002bf6cc (type=<struct>*, size=0x4)
3186 	arg 4: 0x003c0e98 => 0x3c0ea0 (type=unsigned int*, size=0x4)
3186 	retval: 0x0 (type=NTSTATUS, size=0x4
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}  

In particular, it can be deduced from \texttt{arg 1}'s value that \texttt{ProcessDebugPort} is adopted. Unfortunately, this time, we cannot tell from the log that a debugger has not been detected because the output paramater containing this information (\texttt{arg 2}) is a pointer to a \texttt{struct}, which changes based on the type of process information requested. BlueTracer does not yet address these complex cases and we are planning to address them in future versions of the tool.  

\subsubsection*{Anti-Sandbox Timing-based}

Anti-sandbox timing-based checks have the objective of hindering dynamic analysis by making sandboxes time out and, in some cases, they also measure the time elapsed between sleep operations to detect time fast-forwarding strategies. Luckily, BluePill \cite{BluePill} addresses these checks by adopting a sophisticated strategy based on manipulating the timer behaviour of a process. This means that BlueTracer can record timing-based checks without worrying about being detected.

The \texttt{NtDelayExecution} Native API is the lowest level user mode mechanism which can be employed to suspend execution. It takes as input two paramaters: a boolean that makes the Native API alertable when set to \texttt{true} and a \texttt{LARGE\_INTEGER} defining the delay interval. If the value for the second parameter is negative, it specifies the \textit{relative} amount to sleep in units of 100 nanoseconds; otherwise, it indicates an \textit{absolute time}, i.e., the date and time when to stop sleeping. Al-Khaser makes use of this Native API and BlueTracer was able to correctly trace it (\textit{Listing 4.4}). In particular, from the log entry, it can be seen that a negative delay was specified, meaning that a \textit{relative} time to sleep was provided.  

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{NtDelayExecution}},captionpos=b]
~~3160~~ 46332 ntdll.dll!NtDelayExecution
46332 	arg 0: 0x0 (type=bool, size=0x1)
46332 	arg 1: 0xffffffff4d2fa200(hex) (type=LARGE_INTEGER*, size=0x4)
46332    succeeded =>
46332 	retval: 0x0 (type=NTSTATUS, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\texttt{WaitForSingleObject} is also often used to wait until a time-out interval elapses. In input, it receives an handle to an object and a time-out interval in milliseconds. Then, it waits until the provided object is in the signaled state or the time-out runs out. Al-Khaser also adopts this API in its set of timing-based checks. Once more, BlueTracer was capable of recording its occurrence (\textit{Listing 4.5}). It is relevant to point out that the return value is \texttt{0x102}, which indicates that the API has returned because the time-out interval has elapsed, just as expected.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{WaitForSingleObject}},captionpos=b]
~~3160~~ 50077 kernel32.dll!WaitForSingleObject
50077 	arg 0: 0x204 (name=hHandle, type=DWORD, size=0x4)
50077 	arg 1: 0x493e0 (name=dwMilliseconds, type=DWORD, size=0x4)
50077    executed kernel32.dll!WaitForSingleObject =>
50077 	retval: 0x102 (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
} 

The most well-known API for suspending execution is surely \texttt{sleep}, that simply takes as input the number of milliseconds for which execution is to be delayed.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Portion of \texttt{Sleep} loop },captionpos=b]
~~3160~~ 9225 kernel32.dll!Sleep
9225 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 9226 KERNELBASE.dll!Sleep
9226 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
9226    executed KERNELBASE.dll!Sleep =>
9226 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 9227 ntdll.dll!NtYieldExecution
9227    failed (error=0x40000024) =>
9227 	retval: 0x40000024 (type=NTSTATUS, size=0x4)
~~3160~~ 9228 kernel32.dll!Sleep
9228 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 9229 KERNELBASE.dll!Sleep
9229 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
9229    executed KERNELBASE.dll!Sleep =>
9229 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 9230 ntdll.dll!NtYieldExecution
9230    failed (error=0x40000024) =>
9230 	retval: 0x40000024 (type=NTSTATUS, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

Due to its popularity, Al-Khaser had to adopt it and, again, BlueTracer's logs showed evidence of its usage (\textit{Listing 4.6}). Specifically, from the log file, it can be deduced that \texttt{sleep} was used in a loop, as it is invoked many times subsequently.

\subsubsection*{Human Interaction Detection}

The idea behind human interaction detection checks is to uncover the presence of a sandbox based on the lack of human interaction with the system; in fact, in real environments users typically perform some detectable activities when carrying out their tasks. A classical example of such activities is moving the mouse cursor.  

The mouse cursor position can be obtained through the use of the \texttt{GetCursorPos} API, which has a single output parameter containing a pointer to a \texttt{POINT struct}. Such data structure stores the retrieved position of the mouse cursor, in screen coordinates. Al-Khaser employs the \texttt{GetCursorPos} API to check if there is some kind of mouse movement in the sandbox. BlueTracer proved to work well as it traced the API's invocation (\textit{Listing 4.7}).

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={\texttt{GetCursorPos} evidence in the log },captionpos=b]
~~3160~~ 17964 USER32.dll!GetCursorPos
17964 	arg 0: 0x002bf684 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17964    executed USER32.dll!GetCursorPos =>
17964 	arg 0: 0x002bf684 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17964 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 17965 kernel32.dll!Sleep
17965 	arg 0: 0x1388 (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 17966 KERNELBASE.dll!Sleep
17966 	arg 0: 0x1388 (name=dwMilliseconds, type=DWORD, size=0x4)
17966    executed KERNELBASE.dll!Sleep =>
17966 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 17967 USER32.dll!GetCursorPos
17967 	arg 0: 0x002bf698 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17967    executed USER32.dll!GetCursorPos =>
17967 	arg 0: 0x002bf698 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17967 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
} 

It is interesting to notice that, from the log, it can be also deduced how the actual check is carried out by Al-Khaser. In fact, \texttt{GetCursorPos} is called, followed by a \texttt{Sleep} and another \texttt{GetCursorPos} invocation. In light of this, it is likely that an initial cursor position was first retrieved, which was later compared with the cursor position obtained after the sleep operation, with the aim of determining if the mouse cursor had moved in the mean time.
  

\subsubsection*{Anti-Virtualization}
Anti-virtualization checks look for a number of artifacts in the guest operating system introduced by hypervisors which are specific to virtual machines.

A common way to detect virtualization is by checking Windows registry artifacts. The Windows registry is a hierarchical tree-like database containing critical data for both the Windows operating system and its applications. Each node of the tree is a \textit{key} and every key embodies \textit{subkeys} and \textit{values} \cite{Regs}. 

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{RegOpenKeyExW} },captionpos=b]
~~3160~~ 30134 ADVAPI32.dll!RegOpenKeyExW
30134 	arg 0: 0x80000002 (name=hKey, type=DWORD, size=0x4)
30134 	arg 1: HARDWARE\ACPI\DSDT\VBOX__ (name=lpSubKey, type=wchar_t*, size=0x2)
30134 	arg 2: 0x0 (name=ulOptions, type=DWORD, size=0x4)
30134 	arg 3: 0x20019 (name=samDesired, type=DWORD, size=0x4)
30134 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
~~3160~~ 30135 kernel32.dll!RegOpenKeyExW
30135 	arg 0: 0x80000002 (name=hKey, type=DWORD, size=0x4)
30135 	arg 1: HARDWARE\ACPI\DSDT\VBOX__ (name=lpSubKey, type=wchar_t*, size=0x2)
30135 	arg 2: 0x0 (name=ulOptions, type=DWORD, size=0x4)
30135 	arg 3: 0x20019 (name=samDesired, type=DWORD, size=0x4)
30135 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
30135    executed kernel32.dll!RegOpenKeyExW =>
30135 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
30135 	retval: 0x2 (name=Return value, type=(long/int), size=0x4))
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}

The existence of some specific registry keys is enough to reveal the presence of virtualization. For instance, the key \texttt{HKEY\_LOCAL\_MACHINE\textbackslash}\texttt{{HARDWARE}\textbackslash{ACPI}\textbackslash{DSDT}}\texttt{\textbackslash{VBOX}\textbackslash\_\_}
gives away the presence of VirtualBox. Al-Khaser looks for these kinds of Windows registry artifacts and BlueTracer is able to record such events (\textit{Listing 4.8}).

From \textit{Listing 4.8}, it can be observed that the aforementioned registry key is searched through the use of the \texttt{RegOpenKeyExW} API, which normally opens the specified registry key. However, in this case, a "file not found" error value (\texttt{0x2}) is returned since the registry key is not found, thus also confirming BlueTracer's ability to remain hidden.

In addition to Windows registry artifacts, there are also many file system artifacts which can be checked in order to uncover the presence of a virtualized environment. Typically, specific files are searched. Al-Khaser, for instance, looks for a number of files, one of which is the \texttt{VboxMouse.sys} driver of Virtualbox. Once more, BlueTracer was able to trace these file-searching events, including the ones relative to \texttt{VboxMouse.sys} (\textit{Listing 4.9}). 

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={ Log portion relative to the search for \texttt{VboxMouse.sys} search},captionpos=b]
~~3160~~ 24979 kernel32.dll!GetFileAttributesW
24979 	arg 0: C:\Windows\system32\drivers\VBoxMouse.sys
 (name=lpFileName, type=wchar_t*, size=0x2)
~~3160~~ 24980 KERNELBASE.dll!GetFileAttributesW
24980 	arg 0: C:\Windows\system32\drivers\VBoxMouse.sys
 (name=lpFileName, type=wchar_t*, size=0x2)
24980    executed KERNELBASE.dll!GetFileAttributesW =>
24980 	retval: 0xffffffff (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
} 

The \texttt{GetFileAttributesW} API, as the name suggests, is typically employed to obtain file attributes for the specified file. From \textit{Listing 4.9} it can be seen that the API returns -1, since the requested file was not found. Therefore, even in this situation, BlueTracer was also undetected.

\iffalse
-Registry Artifacts
-File system artifacts -> Virtual Devices here?
-Window
-DLLs
\fi

A virtualized environment can be also discovered by looking for specific windows. The \texttt{FindWindow} API returns an handle of a window belonging to a specific class or having the specified name. This API can be exploited to check for the presence of a window associated to a virtualization program. A typical example of this trick, which is implemented by Al-Khaser, is searching for a window named "VBoxTrayToolWnd", as the presence of such window indicates that VirtualBox is being utilized. BlueTracer also detected this check (\textit{Listing 4.10}). As the reader can see, the return value is \texttt{null}, meaning that the window was not found and that BlueTracer did not reveal its presence.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={ Log entry relative to \texttt{FindWindowW}},captionpos=b]
~~3160~~ 35247 USER32.dll!FindWindowW
35247 	arg 0: <null> (name=lpClassName, type=wchar_t*, size=0x2)
35247 	arg 1: VBoxTrayToolWnd (name=lpWindowName, type=wchar_t*, size=0x2)
35247    executed USER32.dll!FindWindowW =>
35247 	retval: 0x0 (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
} 
   

\subsubsection{Anti-Analysis}

\iffalse
Check for processes of common anti-analysis tools
\fi

Lastly, anti-analysis checks are aimed at detecting the existence of processes belonging to popular analysis tools. One of such tools is Process Monitor (\texttt{procmon.exe}), which is an advanced Windows monitoring tool that shows real-time file system, registry and process/thread activity \cite{procmon}. Al-Khaser looks for the processes of many analysis tools, including Process Monitor. Again, BlueTracer was also able to successfully log anti-analysis events, even the ones directed at uncovering the presence of Process Monitor (\textit{Listing 4.11}). From the listing on the next page, it can be seen that the course of action adopted by Al-Khaser is quite straightforward. It first takes a snapshot of all the processes in the system with \texttt{CreateToolhelp32Snapshot}. Then, for each process in the snapshot, it retrieves the corresponding name, through the use of \texttt{Process32FirstW} at the beginning and \texttt{Process32NextW} afterwards, and compares it with \texttt{procmon.exe} via \texttt{StrCmpIW}. 
\newpage
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={\texttt{procmon.exe} search},captionpos=b]
~~3160~~ 53940 kernel32.dll!CreateToolhelp32Snapshot
53940 	arg 0: 0x2 (name=dwFlags, type=DWORD, size=0x4)
53940 	arg 1: 0x0 (name=th32ProcessID, type=DWORD, size=0x4)
53940    executed kernel32.dll!CreateToolhelp32Snapshot =>
53940 	retval: 0x1fc (name=Return value, type=DWORD, size=0x4)
~~3160~~ 53941 kernel32.dll!Process32FirstW
53941 	arg 0: 0x1fc (name=hSnapshot, type=DWORD, size=0x4)
53941 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53941    executed kernel32.dll!Process32FirstW =>
53941 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53941 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53942 SHLWAPI.dll!StrCmpIW
53942 	arg 0: [System Process] (name=psz1, type=wchar_t*, size=0x2)
53942 	arg 1: procmon.exe (name=psz2, type=wchar_t*, size=0x2)
53942    executed SHLWAPI.dll!StrCmpIW =>
53942 	retval: 0xffffffff (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53943 kernel32.dll!Process32NextW
53943 	arg 0: 0x1fc (name=hSnapshot, type=DWORD, size=0x4)
53943 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53943    executed kernel32.dll!Process32NextW =>
53943 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53943 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53944 SHLWAPI.dll!StrCmpIW
53944 	arg 0: System (name=psz1, type=wchar_t*, size=0x2)
53944 	arg 1: procmon.exe (name=psz2, type=wchar_t*, size=0x2)
53944    executed SHLWAPI.dll!StrCmpIW =>
53944 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\section{Malware Samples from Joe Security}

\iffalse
An overview of which is given by Table 4.3.
Showing each check hooked by BluePill and traced by BlueTracer.
Remember main image
\fi

In order to assess BlueTracer's effectiveness with respect to real malware instances, we tested it with five highly evasive samples collected by Joe Security \cite{JoeBox} having unusual evasion tricks that their specialized sandboxing products can take care of. For each sample, the evaluation of BlueTracer's tracing and stealth abilities was conducted by collecting BlueTracer's logs and checking if they were congruous with the sample's actions uncovered by Joe Sandbox, a commercial state-of-the-art stealthy analysis system \cite{JoeSandbox}. Moreover, we used Process Monitor, adequately cloaked by BluePill, as ground truth for what was carried out in the system.
We ran each sample for one hour using BlueTracer's \textbf{Main Image} mode.

An overview of the analyzed samples can be observed from \textit{Table 4.3}.


\begin{table}[h]
\vspace*{0.5cm}
\begin{center}
 \begin{tabular}{||c c c||} 
 \hline
 \textbf{ID} & \textbf{MD5} & \textbf{Name} \\ [0.5ex] 
 \hline\hline
 1 & 0af4ef5069f47a371a0caf22ae2006a6 & \textit{trojan/banker} \\ 
 \hline
 2 & 9437eabf2fe5d32101e3fbf9f6027880 & \textit{dropper} \\
 \hline
 3 & cbdda646a20d95f078393506ecdc0796 & \textit{trojan}\\
 \hline
 4 & cfdd16225e67471f5ef54cab9b3a5558 & Olympic\\
 \hline
 5 & ef694b89ad7addb9a16bb6f26f1efaf7 & CCleaner\\ [1ex] 
 \hline
\end{tabular}
\end{center}
\caption{Tested highly-evasive malware samples}
\end{table}

Let us give a brief description for each of the above samples, based on the information from Joe Sandbox reports:

\begin{itemize}
\item \textbf{1} is an evasive \textit{trojan}, i.e., a seemingly benign malicious program, which contacts phishing domains and drops a set of malicious files on the infected system.
\item \textbf{2} is a \textit{dropper}, that is, a type of trojan which "installs" additional malware on the targeted system. It persists itself and uses a variety of anti-evasion checks, including anti-VM and anti-sandbox controls. 
\item \textbf{3} has a behaviour similar to \textbf{1}'s, since it is an evasive trojan that creates files on the compromised system and contacts malicious phishing domains. However, it is a bit more sophisticated as the number of created files and contacted domains is greater and, in addition, it involves the creation and injection of processes.
\item \textbf{4} is Olympic destroyer, a data-wiping destructive malware which spread and caused damage to the computer network of the 2018 Pyeongchang Winter Olympics \cite{OlympicDestroyer}.  
\item \textbf{5} is a highly-evasive trojanized version of the popular CCleaner utility program, which steals information from the infected system and installs a backdoor.
\end{itemize}

From the obtained results, we could deduce that BlueTracer was successful at tracing the samples' actions while remaining hidden, hence allowing them to perform their original malicious operations. An overview of the evasive actions executed from the samples' main executable which were tracked by BlueTracer and disabled by BluePill can be observed from \textit{Table 4.4} and \textit{Table 4.5}. In particular, the eight categories in which the actions are grouped correspond the ones adopted by BluePill. Specifically, the evasive patterns are classified as follows:

\begin{itemize}
\item \textbf{Anti-debugging (DEBUG)}, which seek to detect the presence of a debugger.
\item \textbf{File-related (FILE)}, which involve file operations.
\item \textbf{GUI-related (GUI)}, which deal with GUI features.
\item \textbf{Process-related (PROC)}, aimed at collecting process information.
\item \textbf{Hardware-related (HW)}, the objective of which is to perform hardware fingerprinting.
\item \textbf{Registry-related (REG)}, that involve registry operations.
\item \textbf{Time-related (TIME)}, which include timing differences and time-stalling techniques.
\item \textbf{WMI-related (WMI)}, whose objective is to make SQL-like queries to applications and installed devices via the Windows Management Instrumentation model.
\end{itemize}  

From the tables on the next page, we can see that some of the evasion tricks previously explained in Section~\ref{Alk} were successfully traced and dismantled, i.e.,
\texttt{GetFileAttributes}, \texttt{GetCursorPos}, \texttt{RegOpenKey} and \texttt{WaitForSingleObject}. In addition to these tricks, there are also some other disabled checks which we did not previously mention. 


\iffalse
2 is memory intensive, coherently with the fact that blabla
\fi


\begin{table}[htp]
\begin{center}
%\begin{sidewaystable}
\hspace*{-0.5cm}
\renewcommand{\arraystretch}{1.8}
 \begin{tabular}{|c|c|c|c|c|} 
 \hline
 \textbf{ID} & \textbf{DEBUG} & \textbf{FILE} & \textbf{GUI} & \textbf{PROC} \\ [0.5ex] 
 \hline\hline
 1 & & & & \\ 
 \hline
 2 & & \makecell{FindFirstFile\\GetFileAttributes} & & \\
 \hline
 3 &  &  &  & NtQuerySystemInformation\\
 \hline
 4 &  &  &  & NtQuerySystemInformation\\
 \hline
 5 &  &  & GetCursorPos &\\ [1ex] 
 \hline
\end{tabular}
%\end{sidewaystable}
\end{center}
\caption{Evasive tricks dismantled by BluePill and tracked by BlueTracer. The shown evasion tricks come from the categories \textbf{DEBUG}, \textbf{FILE}, \textbf{GUI} and \textbf{PROC}.}
%\end{table}

%\begin{table}[h]
\begin{center}
%\begin{sidewaystable}
\renewcommand{\arraystretch}{1.9}
 \begin{tabular}{|c|c|c|c|c|} 
 \hline
 \textbf{ID} & \textbf{HW} & \textbf{REG} & \textbf{TIME} & \textbf{WMI} \\ [0.5ex] 
 \hline\hline
 1 &  &  & GetTickCount & \\ 
 \hline
 2 &  & RegOpenKey & \makecell{GetSystemTimeAsFileTime\\GetTickCount} & \\
 \hline
 3 &  &  &  & \\
 \hline
 4 &  & RegQueryValueEx  & \makecell{GetSystemTimeAsFileTime\\GetTickCount\\WaitForSingleObject} & \\
 \hline
 5 &  & RegOpenKey & \makecell{GetSystemTimeAsFileTime\\GetTickCount\\SetTimer}      
& SysAllocString\\ [1ex] 
 \hline
\end{tabular}
%\end{sidewaystable}
\end{center}
\caption{Evasive tricks dismantled by BluePill and tracked by BlueTracer. The shown evasion tricks come from the categories \textbf{HW}, \textbf{REG}, \textbf{TIME} and \textbf{WMI}.}
\end{table}


\iffalse
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
%\newcommand{\specialcell}[2][c]{%
%  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\renewcommand{\arraystretch}{2}
\begin{tabularx}{\linewidth}{|c|c|c|c|c|}

\hline
\hline
   \textbf{ID} & \textbf{DEBUG} & \textbf{FILE} & \textbf{GUI} & \textbf{PROC} \\
\hline
1     & & & &  \\
\hline 
2       &  & \makecell{FindFirstFileW\\GetFileAttributesW} & &   \\
\hline
3       &  &  &  & NtQuerySystemInformation  \\
\hline
4      &  &  &  & NtQuerySystemInformation   \\
\hline
5      &  &  & GetCursorPos &     \\
\hline
\end{tabularx}
\vspace{0.2cm}
%\caption{Execution times of instrumented benign applications}

%& \textbf{HW} & \textbf{REG} & \textbf{TIME} & \textbf{WMI}

\begin{sidewaystable}[h]
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\renewcommand{\arraystretch}{2}
%\hspace{-1cm}
\def\x{
\begin{tabularx}{\linewidth}{|c|c|c|c|c|c|c|}

\hline
\hline
   \textbf{ID} & \textbf{MD5} & \textbf{Name} & \textbf{HW} & \textbf{REG} & \textbf{TIME} & \textbf{WMI} \\
\hline
1      & 0af4ef5069f47a371a0caf22ae2006a6    &
 \textit{trojan/banker} &  &  & GetTickCount &   \\
\hline 
2      & 9437eabf2fe5d32101e3fbf9f6027880    & \textit{dropper}  &  & RegOpenKey & \makecell{GetSystemTimeAsFileTime\\GetTickCount} &   \\
\hline
3      & cbdda646a20d95f078393506ecdc0796    & \textit{trojan}  &  &  &  &  \\
\hline
4      & cfdd16225e67471f5ef54cab9b3a5558    & Olympic  &  & RegQueryValueEx  & \makecell{GetSystemTimeAsFileTime\\GetTickCount\\WaitForSingleObject}   &    \\
\hline
5      & ef694b89ad7addb9a16bb6f26f1efaf7    & CCleaner  &  & RegOpenKey & \makecell{GetSystemTimeAsFileTime\\GetTickCount\\SetTimer}      
& SysAllocString \\
\hline
\end{tabularx}
}
\scalebox{.9}{\x}
\vspace{0.2cm}
\caption{Execution times of instrumented benign applications}

\end{sidewaystable}
\fi


Let us quickly go through them:
\begin{itemize}
\item \texttt{FindFirstFile} searches a directory for a file or subdirectory matching the provided name. 
\item \texttt{NtQuerySystemInformation}, when its SystemInformationClass parameter is set to SystemProcessInformation (\texttt{0x5}), returns a set of data structures, one for each process running in the system, containing information related to them.
\item \texttt{RegQueryValueEx} retrieves information relative to the provided value name, associated to an open registry key.
\item \texttt{GetTickCount} returns the number of milliseconds elapsed since the start of the system and is typically used for calculating timing differences.
\item \texttt{GetSystemTimeAsFileTime} returns the system's current date and time. 
\item \texttt{SetTimer} generates a timer having the specified time-out value.
\item \texttt{SysAllocString} creates a binary string, in this specific case containing the query to be performed through the Windows Management Instrumentation model.
\end{itemize}

In order to learn as much information as possible regarding the tested samples, for each malicious instance we recorded the size of the associated BlueTracer log, we parsed it with a Python script and we counted the total number events, differentiating between Native APIs, APIs, Callbacks and APCs (\textit{Table 4.6}). The results show how the log sizes are quite heterogeneous, ranging from the 132.5 kB of \textbf{1} to the 173.4 MB of \textbf{5}. Moreover, we can also see how, as expected, APIs are by far the most frequent type of event. Furthermore, we can also observe how callbacks occur for every sample, unlike APCs, which were never found in the logs.

\begin{sidewaystable}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{|Y|Y|YYYY|Y|}

\hline
\hline
   \textbf{ID} & \textbf{Log Size} & \textbf{Native APIs} & \textbf{APIs} & \textbf{Callbacks} & \textbf{APCs} & \textbf{Total} \\
\hline
1      & 132.5 kB    & 0  & 834 & 1 & 0 & 835     \\
\hline
2      & 87.2 MB & 1063 & 492 629 & 11 & 0 & 493 703 \\
\hline
3      & 4.3 MB & 4 & 11 144 & 178 & 0 & 11 326 \\
\hline
4      & 12.3 MB & 446 & 60 542 & 24 & 0 & 61 012 \\
\hline
5      & 173.4 MB & 0 & 615 268 & 5231 & 0 & 620 499 \\
\hline
\end{tabularx}
\vspace{0.1cm}
\caption{Execution times of instrumented benign applications}

\vspace*{0.5cm}
%\end{sidewaystable}
%\begin{sidewaystable}

\begin{tabularx}{\linewidth}{|Y|Y|Y|Y|Y|Y|Y|Y|Y|}

\hline
\hline
   \textbf{ID} & \specialcell{ \textbf{File} \\ \textbf{Activities}} & \specialcell{ \textbf{Registry} \\ \textbf{Activities}} & \specialcell{ \textbf{Process} \\ \textbf{Activities}} & \specialcell{ \textbf{Thread} \\ \textbf{Activities}} & \specialcell{ \textbf{Time} \\ \textbf{Activities}} & \specialcell{ \textbf{Memory} \\ \textbf{Activities}} &  \specialcell{ \textbf{Sys. Info.} \\ \textbf{Activities}} & \specialcell{ \textbf{UI} \\ \textbf{Activities}} \\
\hline
1      & \specialcell{64 \\ (7.66\%)}    & \specialcell{36 \\ (4.32\%)}  &  \specialcell{5 \\ (0.60\%)} & \specialcell{1 \\ (0.12\%)} & \specialcell{20 \\ (2.39\%)} & \specialcell{40 \\ (4.79\%)} & \specialcell{9 \\ (1.08\%)} & 0   \\
\hline
2      &  \specialcell{4836 \\ (0.98\%)}    & \specialcell {68 \\ (0.01\%)}  &  \specialcell{123 \\ (0.02\%)} & \specialcell{54 005 \\ (10.94\%)} & \specialcell{22 629 \\ (4.58\%)} & \specialcell{45 799 \\ (9.28\%)} & \specialcell {27 \\ ($\approx0$\%)} & \specialcell {25 051 \\ (5.07\%)}   \\
\hline
3      & \specialcell{6759 \\ (59.68\%)}    & \specialcell{4 \\ (0.03\%)}  &  \specialcell{78 \\ (0.69\%)} & \specialcell{4 \\ (0.03\%)} & \specialcell{34 \\ (0.30\%)} & \specialcell{435 \\ (3.84\%)} & \specialcell{3 \\ (0.03\%)} & \specialcell{38 \\ (0.34\%)}   \\
\hline
4      & \specialcell{242 \\ (0.40\%)}    & \specialcell{361 \\ (0.59\%)}  &  \specialcell{1676 \\ (2.75\%)} & \specialcell{348 \\ (0.57\%)} & \specialcell{185 \\ (0.30\%)} & \specialcell{5758 \\ (9.44\%)} & \specialcell{57 \\ (0.09\%)} & \specialcell{0}   \\
\hline
5      & \specialcell{4194 \\ (0.68\%)}    & \specialcell{26 224 \\ (4.23\%)}  &  \specialcell{6035 \\ (0.97\%)} & \specialcell{3315 \\ (0.53\%)} & \specialcell{16 346 \\ (2.63\%)} & \specialcell{120 918 \\ (19.84\%)} & \specialcell{647 \\ (0.10\%)} & \specialcell{14 958 \\ (2.41\%)}   \\
\hline
\end{tabularx}
\vspace{0.2cm}
\caption{Execution times of instrumented benign applications}

\end{sidewaystable}

In addition to counting the samples' events from their logs, we also recorded how many events were traced for each of eight different categories, namely, file activities, registry activities, process activities, thread activities, time activities, memory activities, system information-retrieval activities and user interface activities (\textit{Table 4.7}). Such groups are the same as the ones in Joe Sandbox's reports, which were, in fact, employed to determine the appropriate category for each event. From the data in \textit{Table 4.7} we can see that, for \textbf{1} and \textbf{3}, the most common operations are file activities (7.66\% and 59.68\%), coherently with the fact that one of their main actions is to drop files on the infected system. Regarding \textbf{2}, the largest portion of events involved thread activities (10.94\%) and memory activities (9.28\%), as we are dealing with a persistent dropper. Olympic, being a data-wiping malware, also mainly performs memory activities (9.44\%). Lastly, even for CCleaner, the majority of events are memory-related (19.84\%).

\section{Conclusions}
In this chapter we have outlined the results of BlueTracer's experimental evaluation. In order to assess BlueTracer's run-time overhead, we have tested it on a number of applications performing various tasks, employing a four different modes of operation. We have also introduced the overhead per event metric as a way of quantifying the run-time overhead introduced by BlueTracer. The results showed that the typical overhead per event is in the range of 40 - 220 microseconds per operation.
Then we firstly validated BlueTracer with Al-Khaser, an open-source application employed to assess how stealthy an analysis system is with respect to many evasion techniques used in the wild. BlueTracer was able to remain hidden to all the checks performed by Al-Khaser, thus proving to be effective at staying undetected. Furthermore, BlueTracer's tracking abilities also turned out to be efficacious, since evidence of the vast majority of Al-Khaser's techniques was present in BlueTracer's log. Lastly, we assessed BlueTracer's capabilities by conducting tests on real highly evasive malware samples collected by Joe Security. The obtained results showed how BlueTracer was able to track the malicious activities performed by the malware instances, without them noticing it.