% !TEX root = LMThesisNicchi.tex

\chapter{Experimental Evaluation} \label{results}

In this chapter we will illustrate the results obtained during the experimental evaluation of BlueTracer.

We first tested the tool on a set of benign applications performing different tasks, in order to assess its run-time overhead.

Then, we validated BlueTracer using \textit{Al-Khaser} \cite{AlK}, a popular open-source project employed to assess how stealthy a malware analysis system is with respect to a large portion of public evasion techniques used by real malware families.

\iffalse
Finally, we employed BlueTracer to analyze a group of highly evasive real malware samples collected by Joe Security, the proclaimed technology leader for the analysis of evasive malware.
\fi

\iffalse
If JoeBox added differentiate machines
\fi
All the tests were conducted on a VirtualBox (version 5.2.6)  Virtual Machine with 1 CPU core and 3 GB of RAM running Windows 7 32-bit. The specifications of the host machine are:
\begin{itemize}
\item \textbf{Operating System:} Linux Mint 17.3 
\item \textbf{Processor:} Intel Core i7-3537U CPU @ 2.00 GHz $\times$ 2
\item \textbf{RAM:} 8 GB  
\end{itemize}
 

\section{Run-Time Overhead Assessment}

In order to evaluate the run-time overhead introduced by BlueTracer we tested it with a number of benign applications exercising a large number of functions. We had to perform this kind of test on deterministic batch programs to obtain accurate results rather than on real malware samples. This because malware instances have unpredictable behaviour, thus rendering the execution times obtained when running them meaningless.
Having in mind the goal of experimenting with a wide range of different functionalities, we picked a set of well-known Windows applications performing a variety of jobs. We grouped these applications based on the task they carry out, as shown below:

\begin{itemize}
\item \textbf{Collection of system information}
	   \begin{itemize}
	   \item \texttt{Systeminfo.} It outputs a summary of OS-environment parameters. 
	   \item \texttt{System File Checker (SFC).} It scans for corruptions in system files.
	   \item \texttt{Check Disk}. It checks the disks' integrity.
	   \item \texttt{IPConfig}. It displays TCP/IP network configuration values.
	   \item \texttt{Netstat}. It can show active TCP connections as well as TCP and UDP ports on which the computer is listening.
	   \item \texttt{Driver Query}. It presents the list of installed drivers and their properties.
	   \item \texttt{Windows Assessment Tools (WinSAT).} It  measures a number of performance characteristics and reports them.
	   \item \texttt{Powercfg.} It enables to search for common energy-efficiency problems. 
	   \end{itemize}
\item \textbf{Compression programs}
		\begin{itemize}
		\item \texttt{7zip.} Its default output extension is \texttt{.7z}.
		\item \texttt{IZArc.} Its default output extension is \texttt{.zip}.
		\item \texttt{WinRar.} Its default output extension is \texttt{.rar}.
		\end{itemize}
\item \textbf{Encryption Utilities}
		\begin{itemize}
		\item \texttt{Cipher.} It uses Encrypting File System (ESF), based on DESX. 
		\item \texttt{OpenSSL.} It was configured to employ 256-bit CBC AES.
		\item \texttt{Crypt.} It adopts RC2 block encryption.
		\end{itemize}
\item \textbf{Hashing Utilities}
		\begin{itemize}
		\item \texttt{File Checksum Integrity Verifier (FCIV).} It was set to use both MD5 and SHA1.
		\item \texttt{TurboSFV.} It was configured to adopt SHA3-224. 
		\end{itemize}
\end{itemize}

We first recorded the native execution time for each of the aforementioned applications. Then, we ran them under BlueTracer, logging the respective execution times. Specifically, the following BlueTracer modes of operation were employed:

\begin{itemize}
\item \textbf{Empty Image.} All image notification functions are empty, that is, they just increase a global counter value. This means that no analysis routines are inserted at run-time. 
\item \textbf{Empty Routine.} All analysis routines are empty, i.e., all they do is, once again, increase a global counter value.
\item \textbf{Main Image.} Only Native APIs and APIs being directly invoked from the main executable of the pinned application are traced. This is BlueTracer's default mode of operation. 
\item \textbf{Complete.} Every event is traced, also including Native APIs and APIs being invoked outside the main executable (e.g., within libraries).
\end{itemize}

We tested every benign application in the previous page adopting each of the above operation modes, which can be set using BlueTracer's configuration file. Essentially, \textbf{Empty Image} and \textbf{Empty Routine} were utilized to determine the run-time overhead introduced just by the Pin's framework, when no analysis is actually performed. On the contrary, \textbf{Main Image} was adopted to show BlueTracer's overhead during a typical use of the tool, as \textbf{Main Image} is BlueTracer's default mode. Lastly, \textbf{Complete} was employed to determine how BlueTracer's behaves under heavy stress conditions.

We tested each application three times and then recorded the average execution time. For the compression programs, the file being compressed was the Puppy Linux ISO (\texttt{xenialpup-7.5-uefi.iso}), of size 332 MBs. On the other hand, for the encryption and hashing utilities, we used the Ubuntu 18.04 ISO (\texttt{ubuntu-18.04-desktop-amd64}), the size of which is 1.8 GB. During the tests, we also decided to stop the execution of the pinned application if, after it had been running for more than 10 minutes, the log file was greater than 5 GB. This had to be done due to the hard drive limitations of the testing platform.      

The recorded execution times can be observed from \textit{Table 4.1}. As it can be seen, as more demanding modes of operation are employed, the run-time increases, although the increment is not uniform, but is actually quite variable across the different applications.

In light of this, to actually quantify the run-time overhead we decided to adopt the following metric:

\begin{align*}
\text{Overhead per Event} = \frac{T_{instrumented} - T_{native}}{Events}
\end{align*}

where:
\begin{itemize}
\item $T_{instrumented}$ is the application's execution time when executed under BlueTracer with the \textbf{Complete} mode of operation enabled. We chose the \textbf{Complete} mode of operation to quantify the overhead per event in the worst-case situation.
\item $T_{native}$ is the application's native execution time.
\item $Events$ is the total number of Native API and API calls performed by the analyzed application.
\end{itemize}

\textit{Table 4.2} lists the overhead per event value of each benign application for which the execution time in the \textbf{Complete} mode of operation could be obtained. In this case we can see that the typical overhead is approximately in the 4$\times10^{-5}$ - 22$\times10^{-5}$ seconds range, with the compression programs being an exception, as they have a greater overhead per event value than the rest.

\vspace*{0.8cm}
\begin{sidewaystable}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{6}{Y}}

\hline
\hline
   \textbf{Application} & \specialcell{ \textbf{Native} \\ \textbf{(s)}} & \specialcell{ \textbf{Empty Image} \\ \textbf{(s)}} & \specialcell{ \textbf{Empty Routine} \\ \textbf{(s)}} & \specialcell{ \textbf{Main Image} \\ \textbf{(s)}} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} \\
\hline
\texttt{Systeminfo}      & 5.894    & 9.686 (1.64x)  & 12.869 (2.18x) & 15.694 (2.66x) & 26.398 (4.48x)     \\
\texttt{SFC}          & 218.251 & 222.065 (1.02x) & 226.125 (1.04x) & 230.869 (1.06x) & 245.476 (1.12x)       \\
\texttt{Check Disk}       & 101.570     & 171.94 (1.69x) & 181.429 (1.79x) & 454.649 (4.48x) & 600+       \\
\texttt{IPConfig}       & 0.105     & 4.257 (40.54x) & 8.421 (80.20x) & 9.599 (91.42x) & 13.181 (125.53x)      \\
\texttt{Netstat} & 0.085 & 2.563 (30.15x) & 4.630 (54.47x) & 6.902 (81.20x) & 21.129 (248.58x)       \\
\texttt{DriverQuery} & 1.168 & 6.663 (5.70x) & 9.786 (8.38x) & 34.074 (29.17x) & 68.668 (58.79x)     \\
\texttt{WinSat}       & 163.175     & 212.496 (1.30x) & 221.012 (1.35x) & 273.641 (1.68x) & 600+      \\
\texttt{PowerCFG} & 61.333      & 73.325 (1.20x) & 80.018 (1.30x) & 132.466 (2.16x) & 273.882 (4.47x)       \\
\texttt{7zip}       & 175.526     & 212.000 (1.21x) & 225.091 (1.28x) & 227.985 (1.30x) & 233.792 (1.33x)      \\
\texttt{IZArc}      & 30.920     & 52.878 (1.71x) & 56.631 (1.83x) & 61.066 (1.97x) & 65.770 (2.13x)      \\
\texttt{WinRar} & 155.674 & 192.638 (1.24x) & 198.804 (1.28x) & 208.606 (1.34x) & 215.455 (1.38x)      \\
\texttt{Cipher} & 0.028 & 1.817 (64.89x) & 3.787 (135.25x) & 4.435 (158.39x) & 5.064 (180.86x)       \\
\texttt{OpenSSL} & 24.769 & 33.183 (1.34x) & 34.308 (1.39x) & 47.006 (1.90x) & 1524.763 (61.56x)      \\
\texttt{Crypt} & 65.392 & 140.048 (2.14x) & 142.979 (2.19x) & 572.353 (8.75x) & 600+      \\
\texttt{FCIV} & 10.807 & 25.113 (2.32x) & 28.144 (2.60x) & 56.329 (5.21x) & 87.948 (8.14x)       \\
\texttt{TurboSFV} & 34.412 & 57.705 (1.68x) & 62.639 (1.82x) & 66.439 (1.93x) & 74.657 (2.17x)
\\
\hline
\end{tabularx}
\vspace{0.2cm}
\caption{Execution times of instrumented benign applications}

\end{sidewaystable}

\iffalse
\begin{table}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{4}{Y}}
\hline
\hline
\cline{1-2}
   \textbf{Application} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} & \textbf{Events} & \specialcell{ \textbf{Overhead / Event} \\ \textbf{(s)}} \\
\hline
\texttt{Systeminfo}      & 26.398    & 387 476      \\
\texttt{System File Checker}          & each        & 0.01       \\
\texttt{Check Disk}       & stuffed     & 92.50      \\
\texttt{IPConfig}       & stuffed     & 33.33      \\
\texttt{Netstat} & frozen      & 8.99       \\
\texttt{DriverQuery}       & stuffed     & 92.50      \\
\texttt{WinSat}       & stuffed     & 33.33      \\
\texttt{PowerCFG} & frozen      & 8.99       \\
\texttt{7zip}       & stuffed     & 92.50      \\
\texttt{IZArc}      & stuffed     & 33.33      \\
\texttt{WinRar} & frozen      & 8.99       \\
\texttt{Cipher} & frozen      & 8.99       \\
\texttt{OpenSSL}       & stuffed     & 92.50      \\
\texttt{Crypt}      & stuffed     & 33.33      \\
\texttt{FCIV} & frozen      & 8.99       \\
\hline
\end{tabularx}
\caption{Run-time overhead for benign applications}
\end{table}
\fi

\vspace*{0.8cm}
\begin{sidewaystable}
\centering
%\begin{tabular}{cccccc}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\begin{tabularx}{\linewidth}{*{6}{Y}}

\hline
\hline
   \textbf{Application} & \specialcell{ \textbf{Native} \\ \textbf{(s)}} & \specialcell{ \textbf{Complete} \\ \textbf{(s)}} & \textbf{Events} & \specialcell{ \textbf{Overhead per Event} \\  \textbf{($10^-5$ s)} }  \\
\hline
\texttt{Systeminfo}      & 5.894    & 26.398  & 387 476 & $5.291$    \\
\texttt{SFC}          & 218.251 & 245.476 & 333 781 & $8.156$ \\
\texttt{IPConfig}       & 0.105 & 13.181 & 94 313 & $13.864$      \\
\texttt{Netstat} & 0.085 & 21.129 & 542 649 & $3.878$       \\
\texttt{DriverQuery} & 1.168 & 68.668 & 1 735 859 & $3.860$            \\
\texttt{PowerCFG} & 61.333 & 273.882 & 4 497 247 & $4.726$       \\
\texttt{7zip}       & 175.526 & 233.792 & 146 578 & $39.751$      \\
\texttt{IZArc}      & 30.920 & 65.770 & 109 142 & $31.931$      \\
\texttt{WinRar} & 155.674 & 215.455 & 84 329 & $70.890$      \\
\texttt{Cipher} & 0.028 & 4.435 & 24 141 & $18.255$           \\
\texttt{OpenSSL} & 24.769 & 1524.763 & 57 410 809 & $2.613$                \\
\texttt{FCIV} & 10.807 & 87.948 & 725 133 &  $10.638$               \\
\texttt{TurboSFV} & 34.412 & 74.657 & 183 455 & $21.937$ 
\\
\hline
\end{tabularx}
\vspace{0.2cm}
\caption{Run-time overhead for benign applications}

\end{sidewaystable}

\vspace{-2cm}
\section{Al-Khaser}
Al-Khaser \cite{AlK} is a popular open-source application which performs a large number of common checks employed by malware families to determine if they are being executed in an analysis environment. It is typically utilized to assess how stealthy and well hidden a malware analysis system is. For this reason, we chose Al-Khaser as our main validation tool.

The checks implemented by Al-Khaser are divided into categories, with the most significant ones being the following:
\begin{itemize}
\item \textbf{Anti-Debugging}, aimed at detecting the presence of a debugger.
\item \textbf{Anti-Sandbox Timing-based}, the purpose of which is to let sandboxes time out in order to defy analysis. 
\item \textbf{Human Interaction Detection}, which seek to discover the presence of a sandbox by looking for the lack of human interaction with the system.
\item \textbf{Anti-Virtualization}, which have the objective of exposing the use of virtualization and full-system emulation. 
\item \textbf{Anti-Analysis}, aimed at uncovering the employment of common analysis tools (e.g OllyDbg, IDA Pro, etc. ).
\end{itemize}  

When Al-Khaser's executable is run, all the checks are performed and the outcome of each one of them can be easily observed from the command line: \texttt{GOOD} is printed if the analysis product succeeded at remaining hidden, and \texttt{BAD} otherwise. 

To validate BlueTracer, Al-Khaser was run under it in the default \textbf{Main Image} mode. The result was that BlueTracer managed to remain undetected with respect to all the checks performed by Al-Khaser. From this outcome we obtained a first confirmation of BlueTracer's ability to hide its presence. 

Furthermore, to also validate BlueTracer's tracing power, we analyzed the logs obtained when running Al-Khaser, with the objective of finding evidence of the performed evasion checks.
Even in this case, BlueTracer performed well, as the majority of the checks could easily be deduced from the log file. 

Let us now show how some of these checks appeared on the log, in order to give a better idea of what BlueTracer is capable of. To be as clear as possible, we will use the same checks categorization as Al-Khaser's.

\subsubsection*{Anti-Debugging}

Anti-debugging checks are essentially aimed at determining if a program is running under a debugger. As already mentioned in Section~\ref{Debugger}, there exist Windows APIs whose objective is exactly to discover if the calling process is being debugged.
A well-known API of this kind is \texttt{IsDebuggerPresent}, which returns a nonzero value if the calling process is running in the context of a debugger and zero otherwise. Such API is employed in one of Al-Khaser's anti-debugging checks and is appropriately recorded by BlueTracer (\textit{Listing 4.1}). As it can be seen below, the return value is zero, as no debugger is detected.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{IsDebuggerPresent}},captionpos=b]
~~3160~~ 562 kernel32.dll!IsDebuggerPresent
~~3160~~ 563 KERNELBASE.dll!IsDebuggerPresent
563    executed KERNELBASE.dll!IsDebuggerPresent =>
563 	retval: 0x0 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}

Another popular Windows API for debug detection is \texttt{CheckRemoteDebuggerPresent}, which determines if the specified process is being debugged by a "remote" debugger, i.e., a debugger residing in parallel and different process. Its second argument is a pointer to a boolean, which is set to true if the provided process is being debugged, or false otherwise. Al-Khaser also adopts this API, and, again, BlueTracer correctly logged its invocation (\textit{Listing 4.2}). In addition, it is worth noting that the output value for the second argument (\texttt{arg 1}) is 
false (\texttt{0x0}), thus showing once more that a debugger was not discovered.   

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{CheckRemoteDebuggerPresent}},captionpos=b]
~~3160~~ 1450 kernel32.dll!CheckRemoteDebuggerPresent
1450 	arg 0: 0xffffffff (name=hProcess, type=DWORD, size=0x4)
1450 	arg 1: 0x002bf710 => 0x0 (name=pbDebuggerPresent, type=(long/int)*, size=0x4)
1450    executed kernel32.dll!CheckRemoteDebuggerPresent =>
1450 	arg 1: 0x002bf710 => 0x0 (name=pbDebuggerPresent, type=(long/int)*, size=0x4)
1450 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}

Debugger detection is not only achieved through the use of Windows APIs. In fact, there are also some Native APIs which can be used for this purpose. One of them is \texttt{NtQueryInformationProcess}, which retrieves information related to the specified process. Its second parameter is utilized to specify the type of process information to be retrieved. When set to \texttt{ProcessDebugPort} (value \texttt{0x7}), the Native API provides information on whether the supplied process is being debugged. Specifically, if a debugger is present, the \texttt{ProcessInformation} output parameter is set to a non-zero port number, while, if the process is not under a debugger, this parameter is set to zero \cite{Sikorski:2012:PMA:2181153}. Al-Khaser performs this check and, once more, BlueTracer recorded it (\textit{Listing 4.3}). In particular, it can be deduced from \texttt{arg 1}'s value that \texttt{ProcessDebugPort} is adopted. Unfortunately, this time, we cannot tell from the log that a debugger has not been detected because the output paramater containing this information (\texttt{arg 2}) is a pointer to a \texttt{struct}, which changes based on the type of process information requested. BlueTracer does not yet address these complex cases and we are planning to address them in future versions of the tool.  

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{NtQueryInformationProcess}},captionpos=b]
~~3160~~ 3186 ntdll.dll!NtQueryInformationProcess
3186 	arg 0: 0xffffffff (type=HANDLE, size=0x4)
3186 	arg 1: 0x7 (type=int, size=0x4)
3186 	arg 2: 0x002bf6cc (type=<struct>*, size=0x4)
3186 	arg 3: 0x0 (type=unsigned int, size=0x4)
3186 	arg 4: 0x003c0e98 (type=unsigned int*, size=0x4)
3186    succeeded =>
3186 	arg 2: 0x002bf6cc (type=<struct>*, size=0x4)
3186 	arg 4: 0x003c0e98 => 0x3c0ea0 (type=unsigned int*, size=0x4)
3186 	retval: 0x0 (type=NTSTATUS, size=0x4
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}  

\subsubsection*{Anti-Sandbox Timing-based}

Anti-sandbox timing-based checks have the objective of hindering dynamic analysis by making sandboxes time out and, in some cases, they also measure the time elapsed between sleep operations to detect time fast-forwarding strategies. Luckily, BluePill \cite{BluePill} addresses these checks by adopting a sophisticated strategy based on manipulating the timer behaviour of a process. This means that BlueTracer can record timing-based checks without worrying about being detected.

The \texttt{NtDelayExecution} Native API is lowest level user mode mechanism which can be employed to suspend execution. It takes as input two paramaters: a boolean that makes the Native API alertable when set to \texttt{true} and a \texttt{LARGE\_INTEGER} defining the delay interval. If the value for the second parameter is negative, it specifies the \textit{relative} amount to sleep in units of 100 nanoseconds; otherwise, it indicates an \textit{absolute time}, i.e., the date and time when to stop sleeping. Al-Khaser makes use of this Native API and BlueTracer was able to correctly trace it (\textit{Listing 4.4}). In particular, from the log entry, it can be seen that a negative delay was specified, meaning that a \textit{relative} time to sleep was provided.  

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{NtDelayExecution}},captionpos=b]
~~3160~~ 46332 ntdll.dll!NtDelayExecution
46332 	arg 0: 0x0 (type=bool, size=0x1)
46332 	arg 1: 0xffffffff4d2fa200(hex) (type=LARGE_INTEGER*, size=0x4)
46332    succeeded =>
46332 	retval: 0x0 (type=NTSTATUS, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\texttt{WaitForSingleObject} is also often used to wait until a time-out interval elapses. In input, it receives an handle to an object and a time-out interval in milliseconds. Then, it waits until the provided object is in the signaled state or the time-out runs out. Al-Khaser also adopts this API in its set of timing-based checks. Once more, BlueTracer was capable of recording its occurrence (\textit{Listing 4.5}). It is relevant to point out that the return value is \texttt{0x102}, which indicates that the API has returned because the time-out interval has elapsed, just as expected.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{WaitForSingleObject}},captionpos=b]
~~3160~~ 50077 kernel32.dll!WaitForSingleObject
50077 	arg 0: 0x204 (name=hHandle, type=DWORD, size=0x4)
50077 	arg 1: 0x493e0 (name=dwMilliseconds, type=DWORD, size=0x4)
50077    executed kernel32.dll!WaitForSingleObject =>
50077 	retval: 0x102 (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
} 

The most well-known API for suspending execution is surely \texttt{sleep}, that simply takes as input the number of milliseconds for which execution is to be delayed. Due to its popularity, Al-Khaser had to adopt it and, again, BlueTracer's logs showed evidence of its usage (\textit{Listing 4.6}). Specifically, from the log file, it can be deduced that \texttt{sleep} was used in a loop, as it is invoked many times subsequently.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Portion of \texttt{Sleep} loop },captionpos=b]
~~3160~~ 9225 kernel32.dll!Sleep
9225 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 9226 KERNELBASE.dll!Sleep
9226 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
9226    executed KERNELBASE.dll!Sleep =>
9226 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 9227 ntdll.dll!NtYieldExecution
9227    failed (error=0x40000024) =>
9227 	retval: 0x40000024 (type=NTSTATUS, size=0x4)
~~3160~~ 9228 kernel32.dll!Sleep
9228 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 9229 KERNELBASE.dll!Sleep
9229 	arg 0: 0xf (name=dwMilliseconds, type=DWORD, size=0x4)
9229    executed KERNELBASE.dll!Sleep =>
9229 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 9230 ntdll.dll!NtYieldExecution
9230    failed (error=0x40000024) =>
9230 	retval: 0x40000024 (type=NTSTATUS, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\subsubsection*{Human Interaction Detection}

The idea behind human interaction detection checks is to uncover the presence of a sandbox based on the lack of human interaction with the system; in fact, in real environments users typically perform some detectable activities when carrying out their tasks. A classical example of such activities is moving the mouse cursor.  

The mouse cursor position can be obtained through the use of the \texttt{GetCursorPos} API, which has a single output parameter containing a pointer to a \texttt{POINT struct}. Such data structure stores the retrieved position of the mouse cursor, in screen coordinates. Al-Khaser employs the \texttt{GetCursorPos} API to check if there is some kind of mouse movement in the sandbox. Even in this case, BlueTracer proved to work well as it traced the API's invocation (\textit{Listing 4.7}). It is interesting to notice that, from the log, it can be also deduced how the actual check is carried out by Al-Khaser. In fact, \texttt{GetCursorPos} is called, followed by a \texttt{Sleep} and another \texttt{GetCursorPos} invocation. In light of this, it is likely that an initial cursor position was first retrieved, which was later compared with the cursor position obtained after the sleep operation, with the aim of determining if the mouse cursor had moved in the mean time.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={\texttt{GetCursorPos} evidence in the log },captionpos=b]
~~3160~~ 17964 USER32.dll!GetCursorPos
17964 	arg 0: 0x002bf684 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17964    executed USER32.dll!GetCursorPos =>
17964 	arg 0: 0x002bf684 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17964 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 17965 kernel32.dll!Sleep
17965 	arg 0: 0x1388 (name=dwMilliseconds, type=DWORD, size=0x4)
~~3160~~ 17966 KERNELBASE.dll!Sleep
17966 	arg 0: 0x1388 (name=dwMilliseconds, type=DWORD, size=0x4)
17966    executed KERNELBASE.dll!Sleep =>
17966 	retval: 0x00000000 (name=Return value, type=void, size=0x0)
~~3160~~ 17967 USER32.dll!GetCursorPos
17967 	arg 0: 0x002bf698 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17967    executed USER32.dll!GetCursorPos =>
17967 	arg 0: 0x002bf698 (name=lpPoint, type=struct*|tagPOINT, size=0x40)
17967 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\subsubsection*{Anti-Virtualization}
Anti-virtualization checks look for a number of artifacts in the guest operating system introduced by hypervisors which are specific to virtual machines.

A common way to detect virtualization is by checking Windows registry artifacts. The Windows registry is a hierarchical tree-like database containing critical data for both the Windows operating system and its applications. Each node of the tree is a \textit{key} and every key embodies \textit{subkeys} and \textit{values} \cite{Regs}. The existence of some specific registry keys is enough to reveal the presence of virtualization. For instance, the key \texttt{HKEY\_LOCAL\_MACHINE\textbackslash}\texttt{{HARDWARE}\textbackslash{ACPI}\textbackslash{DSDT}}\texttt{\textbackslash{VBOX}\textbackslash\_\_}
gives away the presence of VirtualBox. Al-Khaser looks for these kinds of Windows registry artifacts and BlueTracer is able to record such events (\textit{Listing 4.8}). From the listing below, it can be observed that the aforementioned registry key is searched through the use of the \texttt{RegOpenKeyExW} API, which normally opens the specified registry key. However, in this case, a file not found error value (\texttt{0x2}) is returned since the registry key is not found, thus also confirming BlueTracer's ability to remain hidden.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={Log entry relative to \texttt{RegOpenKeyExW} },captionpos=b]
~~3160~~ 30134 ADVAPI32.dll!RegOpenKeyExW
30134 	arg 0: 0x80000002 (name=hKey, type=DWORD, size=0x4)
30134 	arg 1: HARDWARE\ACPI\DSDT\VBOX__ (name=lpSubKey, type=wchar_t*, size=0x2)
30134 	arg 2: 0x0 (name=ulOptions, type=DWORD, size=0x4)
30134 	arg 3: 0x20019 (name=samDesired, type=DWORD, size=0x4)
30134 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
~~3160~~ 30135 kernel32.dll!RegOpenKeyExW
30135 	arg 0: 0x80000002 (name=hKey, type=DWORD, size=0x4)
30135 	arg 1: HARDWARE\ACPI\DSDT\VBOX__ (name=lpSubKey, type=wchar_t*, size=0x2)
30135 	arg 2: 0x0 (name=ulOptions, type=DWORD, size=0x4)
30135 	arg 3: 0x20019 (name=samDesired, type=DWORD, size=0x4)
30135 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
30135    executed kernel32.dll!RegOpenKeyExW =>
30135 	arg 4: 0x002bf6e4 => 0x0 (name=phkResult, type=DWORD*, size=0x4)
30135 	retval: 0x2 (name=Return value, type=(long/int), size=0x4))
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

In addition to Windows registry artifacts, there are also many file system artifacts which can be checked in order to uncover the presence of a virtualized environment. Typically, specific files are searched. Al-Khaser, for instance, looks for a number of files, one of which is the \texttt{VboxMouse.sys} driver of Virtualbox. Once more, BlueTracer was able to trace these file-searching events, including the ones relative to \texttt{VboxMouse.sys} (\textit{Listing 4.9}). The \texttt{GetFileAttributesW} API, as the name suggests, is typically employed to obtain file attributes for the specified file. From \textit{Listing 4.9} it can be seen that the API returns -1, since the requested file was not found. Therefore, even in this situation, BlueTracer was also undetected.

\vspace{1cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={ Log portion relative to the search for \texttt{VboxMouse.sys} search},captionpos=b]
~~3160~~ 24979 kernel32.dll!GetFileAttributesW
24979 	arg 0: C:\Windows\system32\drivers\VBoxMouse.sys
 (name=lpFileName, type=wchar_t*, size=0x2)
~~3160~~ 24980 KERNELBASE.dll!GetFileAttributesW
24980 	arg 0: C:\Windows\system32\drivers\VBoxMouse.sys
 (name=lpFileName, type=wchar_t*, size=0x2)
24980    executed KERNELBASE.dll!GetFileAttributesW =>
24980 	retval: 0xffffffff (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}     

\iffalse
-Registry Artifacts
-File system artifacts -> Virtual Devices here?
-Window
-DLLs
\fi

A virtualized environment can be also discovered by looking for specific windows. The \texttt{FindWindow} API returns an handle of a window belonging to a specific class or having the specified name. This API can be exploited to check for the presence of a window associated to a virtualization program. A typical example of this trick, which is implemented by Al-Khaser, is searching for a window named "VBoxTrayToolWnd", as the presence of such window indicates that VirtualBox is being utilized. BlueTracer also detected this check (\textit{Listing 4.10}). As it can be seen, the return value is \texttt{null}, meaning that the window was not found and that BlueTracer did not reveal its presence.

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={ Log entry relative to \texttt{FindWindowW}},captionpos=b]
~~3160~~ 35247 USER32.dll!FindWindowW
35247 	arg 0: <null> (name=lpClassName, type=wchar_t*, size=0x2)
35247 	arg 1: VBoxTrayToolWnd (name=lpWindowName, type=wchar_t*, size=0x2)
35247    executed USER32.dll!FindWindowW =>
35247 	retval: 0x0 (name=Return value, type=DWORD, size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}    

\subsubsection{Anti-Analysis}

\iffalse
Check for processes of common anti-analysis tools
\fi

Lastly, anti-analysis checks are aimed at detecting the existence of processes belonging to popular analysis tools. One of such tools is Process Monitor (\texttt{procmon.exe}), which is an advanced Windows monitoring tool that shows real-time file system, registry and process/thread activity \cite{procmon}. Al-Khaser looks for the processes of many analysis tools, including the process associated to Process Monitor. Again, BlueTracer was also able to successfully log anti-analysis events, even the ones directed at uncovering the presence of Process Monitor (\textit{Listing 4.11}). From the listing below, it can be seen that the course of action adopted by Al-Khaser is quite straightforward. It first takes a snapshot of all the processes in the system with \texttt{CreateToolhelp32Snapshot}. Then, for each process in the snapshot, it retrieves the corresponding name, through the use of \texttt{Process32FirstW} at the beginning and \texttt{Process32NextW} afterwards, and compares it with \texttt{procmon.exe} via \texttt{StrCmpIW}. 

\vspace{0.5cm}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=none, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}
\begin{lstlisting}[caption={\texttt{procmon.exe} search},captionpos=b]
~~3160~~ 53940 kernel32.dll!CreateToolhelp32Snapshot
53940 	arg 0: 0x2 (name=dwFlags, type=DWORD, size=0x4)
53940 	arg 1: 0x0 (name=th32ProcessID, type=DWORD, size=0x4)
53940    executed kernel32.dll!CreateToolhelp32Snapshot =>
53940 	retval: 0x1fc (name=Return value, type=DWORD, size=0x4)
~~3160~~ 53941 kernel32.dll!Process32FirstW
53941 	arg 0: 0x1fc (name=hSnapshot, type=DWORD, size=0x4)
53941 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53941    executed kernel32.dll!Process32FirstW =>
53941 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53941 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53942 SHLWAPI.dll!StrCmpIW
53942 	arg 0: [System Process] (name=psz1, type=wchar_t*, size=0x2)
53942 	arg 1: procmon.exe (name=psz2, type=wchar_t*, size=0x2)
53942    executed SHLWAPI.dll!StrCmpIW =>
53942 	retval: 0xffffffff (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53943 kernel32.dll!Process32NextW
53943 	arg 0: 0x1fc (name=hSnapshot, type=DWORD, size=0x4)
53943 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53943    executed kernel32.dll!Process32NextW =>
53943 	arg 1: 0x002b7408 (name=lppe, type=struct*|tagPROCESSENTRY32W, size=0x1160)
53943 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
~~3160~~ 53944 SHLWAPI.dll!StrCmpIW
53944 	arg 0: System (name=psz1, type=wchar_t*, size=0x2)
53944 	arg 1: procmon.exe (name=psz2, type=wchar_t*, size=0x2)
53944    executed SHLWAPI.dll!StrCmpIW =>
53944 	retval: 0x1 (name=Return value, type=(long/int), size=0x4)
\end{lstlisting}
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{ao}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    basicstyle=\footnotesize\ttfamily,
    basewidth = {.48em}
}   

\iffalse
\section{JoeBox}
\fi

\section{Conclusions}
In this chapter we have outlined the results of BlueTracer's experimental evaluation. In order to assess BlueTracer's run-time overhead, we have tested it on a number of applications performing various tasks, employing a four different modes of operation. We have also introduced the overhead per event metric as a way of quantifying the run-time overhead introduced by BlueTracer. The results showed that the typical overhead per event is in the 4$\times10^{-5}$ - 22$\times10^{-5}$ seconds range.
Then we validated BlueTracer with Al-Khaser, an open-source application employed to assess how stealthy an analysis system is with respect to many evasion techniques used in the wild. BlueTracer was able to remain hidden to all the checks performed by Al-Khaser, thus proving to be effective at staying undetected. Furthermore, BlueTracer's tracking abilities also turned out to be efficacious, since evidence of the vast majority of Al-Khaser's techniques was present in BlueTracer's log.